<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Assembly Lang</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="Assembly Learning.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">ABOUT Assembly</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="8086-assembly/index.html"><strong aria-hidden="true">1.</strong> Knowledge</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="8086-assembly/01基础知识.html"><strong aria-hidden="true">1.1.</strong> ch1</a></li><li class="chapter-item expanded "><a href="8086-assembly/02寄存器.html"><strong aria-hidden="true">1.2.</strong> ch2</a></li><li class="chapter-item expanded "><a href="8086-assembly/03寄存器.html"><strong aria-hidden="true">1.3.</strong> ch3</a></li><li class="chapter-item expanded "><a href="8086-assembly/04第一个程序.html"><strong aria-hidden="true">1.4.</strong> ch4</a></li><li class="chapter-item expanded "><a href="8086-assembly/05[BX]和loop.html"><strong aria-hidden="true">1.5.</strong> ch5</a></li><li class="chapter-item expanded "><a href="8086-assembly/06段.html"><strong aria-hidden="true">1.6.</strong> ch6</a></li><li class="chapter-item expanded "><a href="8086-assembly/07寻址之前.html"><strong aria-hidden="true">1.7.</strong> ch7</a></li><li class="chapter-item expanded "><a href="8086-assembly/08寻址及其他.html"><strong aria-hidden="true">1.8.</strong> ch8</a></li><li class="chapter-item expanded "><a href="8086-assembly/09转移指令.html"><strong aria-hidden="true">1.9.</strong> ch9</a></li><li class="chapter-item expanded "><a href="8086-assembly/10OVA.html"><strong aria-hidden="true">1.10.</strong> ch10</a></li><li class="chapter-item expanded "><a href="8086-assembly/11CALL&RET.html"><strong aria-hidden="true">1.11.</strong> ch11</a></li><li class="chapter-item expanded "><a href="8086-assembly/12乘法与函数.html"><strong aria-hidden="true">1.12.</strong> ch12</a></li><li class="chapter-item expanded "><a href="8086-assembly/13标志寄存器.html"><strong aria-hidden="true">1.13.</strong> ch13</a></li><li class="chapter-item expanded "><a href="8086-assembly/14内中断.html"><strong aria-hidden="true">1.14.</strong> ch14</a></li><li class="chapter-item expanded "><a href="8086-assembly/15int指令.html"><strong aria-hidden="true">1.15.</strong> ch15</a></li><li class="chapter-item expanded "><a href="8086-assembly/16端口.html"><strong aria-hidden="true">1.16.</strong> ch16</a></li><li class="chapter-item expanded "><a href="8086-assembly/17其他.html"><strong aria-hidden="true">1.17.</strong> ch17</a></li></ol></li><li class="chapter-item expanded "><a href="Labs/index.html"><strong aria-hidden="true">2.</strong> Labs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Labs/lab1.html"><strong aria-hidden="true">2.1.</strong> lab1</a></li><li class="chapter-item expanded "><a href="Labs/lab2.html"><strong aria-hidden="true">2.2.</strong> lab2</a></li><li class="chapter-item expanded "><a href="Labs/lab3.html"><strong aria-hidden="true">2.3.</strong> lab3</a></li><li class="chapter-item expanded "><a href="Labs/lab4.html"><strong aria-hidden="true">2.4.</strong> lab4</a></li><li class="chapter-item expanded "><a href="Labs/lab5.html"><strong aria-hidden="true">2.5.</strong> lab5</a></li><li class="chapter-item expanded "><a href="Labs/lab6.html"><strong aria-hidden="true">2.6.</strong> lab6</a></li><li class="chapter-item expanded "><a href="Labs/lab7.html"><strong aria-hidden="true">2.7.</strong> lab7</a></li><li class="chapter-item expanded "><a href="Labs/lab8.html"><strong aria-hidden="true">2.8.</strong> lab8</a></li><li class="chapter-item expanded "><a href="Labs/lab9.html"><strong aria-hidden="true">2.9.</strong> lab9</a></li><li class="chapter-item expanded "><a href="Labs/lab10.html"><strong aria-hidden="true">2.10.</strong> lab10</a></li><li class="chapter-item expanded "><a href="Labs/proj1.html"><strong aria-hidden="true">2.11.</strong> project1</a></li><li class="chapter-item expanded "><a href="Labs/lab11.html"><strong aria-hidden="true">2.12.</strong> lab11</a></li><li class="chapter-item expanded "><a href="Labs/lab12.html"><strong aria-hidden="true">2.13.</strong> lab12</a></li><li class="chapter-item expanded "><a href="Labs/lab13.html"><strong aria-hidden="true">2.14.</strong> lab13</a></li><li class="chapter-item expanded "><a href="Labs/lab14.html"><strong aria-hidden="true">2.15.</strong> lab14</a></li><li class="chapter-item expanded "><a href="Labs/lab15.html"><strong aria-hidden="true">2.16.</strong> lab15</a></li><li class="chapter-item expanded "><a href="Labs/lab16.html"><strong aria-hidden="true">2.17.</strong> lab16</a></li><li class="chapter-item expanded "><a href="Labs/proj2.html"><strong aria-hidden="true">2.18.</strong> project2</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Assembly Lang</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/TephrocactusMYC/Assembly-WANGSHAUNG" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="汇编语言学习"><a class="header" href="#汇编语言学习">汇编语言学习</a></h1>
<p>内容主要来自于王爽的《汇编语言》第四版。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="8086汇编语言学习"><a class="header" href="#8086汇编语言学习">8086汇编语言学习</a></h1>
<p><a href="https://www.bilibili.com/video/BV1CJ411D7yD/?share_source=copy_web&amp;vd_source=89fdd6c33222facf5d82736180e256cc">视频【8086汇编语言精讲】</a>,是B站的一个教学</p>
<p>配套王爽的《汇编语言》第四版。</p>
<p><a href="https://www.bilibili.com/video/BV1mt411R7Xv/?share_source=copy_web&amp;vd_source=89fdd6c33222facf5d82736180e256cc">B站编程讲解【汇编语言从0开始 重制版 自学必备(配套王爽汇编语言第三版或第四版)】</a></p>
<p><a href="https://blog.csdn.net/Dueser/article/details/120970387">CSDN一个人的课后解答</a></p>
<p><a href="https://blog.csdn.net/weixin_43362650/article/details/117305075">CSDN上一个人第三版的实验</a></p>
<p><a href="https://blog.csdn.net/yangzijiangac/article/details/114376550">CSDN上另一个人的答案</a></p>
<p><a href="https://blog.csdn.net/qq_42777804/article/details/90512159">CSDN上的监测点答案</a></p>
<p><a href="https://www.cnblogs.com/drperry/p/12380038.html">一个移位的博客，纯字典</a></p>
<p><a href="https://blog.csdn.net/skies_/category_11494369.html?spm=1001.2014.3001.5482">一个CSDN博主的专栏，很全的检测点答案和部分实验答案</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="视频"><a class="header" href="#视频">视频</a></h1>
<h2 id="从机器语言到汇编语言"><a class="header" href="#从机器语言到汇编语言">从机器语言到汇编语言</a></h2>
<p>机器语言，过于繁琐和难以编写。</p>
<h2 id="汇编是什么"><a class="header" href="#汇编是什么">汇编是什么？</a></h2>
<p>实际上就是机器语言的助记符，给机器码起不同的有意义的名字</p>
<h2 id="汇编语言的组成"><a class="header" href="#汇编语言的组成">汇编语言的组成</a></h2>
<ol>
<li>汇编指令（核心）：机器码的助记符，有对应的机器码</li>
<li>伪指令：没有对应的机器码，计算机并不执行，由编译器执行</li>
<li>其他符号，由编译器识别，没有对应的机器码</li>
</ol>
<h2 id="cpu寄存器与内存"><a class="header" href="#cpu寄存器与内存">CPU、寄存器与内存</a></h2>
<p>CPU负责运算和指令执行</p>
<p>内存帮助CPU读取存储数据，CPU通过寻址来访问内存，进行数据读写</p>
<p>为了效率，寄存器充当暂存</p>
<h2 id="内存之中存什么"><a class="header" href="#内存之中存什么">内存之中存什么</a></h2>
<p>指令和数据都有</p>
<p><img src="8086-assembly/image-1.png" alt="Alt text" /></p>
<h2 id="存储单元"><a class="header" href="#存储单元">存储单元</a></h2>
<p>存储器被划分为若干个存储单元，每个存1Byte</p>
<h2 id="cpu对存储器的读写"><a class="header" href="#cpu对存储器的读写">CPU对存储器的读写</a></h2>
<p>存储单元被按顺序编号，编号就是地址</p>
<p>CPU要从内存中读取数据，就需要地址</p>
<p>因此需要三种信息：</p>
<ul>
<li>地址信息</li>
<li>控制信息</li>
<li>数据信息</li>
</ul>
<h2 id="小结"><a class="header" href="#小结">小结</a></h2>
<p>汇编指令和机器指令一一对应，每一种CPU都有自己的汇编指令集</p>
<h2 id="扩展知识"><a class="header" href="#扩展知识">扩展知识</a></h2>
<p>大部分为计组的内容。</p>
<h1 id="书"><a class="header" href="#书">书</a></h1>
<p><img src="8086-assembly/image.png" alt="Alt text" /></p>
<h2 id="总线"><a class="header" href="#总线">总线</a></h2>
<p>需要知道地址总线、数据总线、控制总线，其宽度对应的内容。</p>
<h2 id="检测点11"><a class="header" href="#检测点11">检测点1.1</a></h2>
<ol>
<li>$1KB=1024*8 bit=2^{13} bit$, 宽度为13</li>
<li>1024，0-1023</li>
<li>8192，1024</li>
<li>$2^{30},2^{20},2^{10}$</li>
<li>64,1,16,4</li>
<li>1,1,2,4</li>
<li>512,256</li>
<li>二进制</li>
</ol>
<h2 id="其他"><a class="header" href="#其他">其他</a></h2>
<p>后面还有一些OS的知识，学过的应该不需要再看了</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内容"><a class="header" href="#内容">内容</a></h1>
<h2 id="寄存器"><a class="header" href="#寄存器">寄存器</a></h2>
<p>8086由十四个寄存器</p>
<h2 id="通用寄存器"><a class="header" href="#通用寄存器">通用寄存器</a></h2>
<p>AX BX CX DX</p>
<p>用于存放一般性数据</p>
<p>都是16位的，但又分为高八位和第八位</p>
<p>比如AX分为AH和AL
<img src="8086-assembly/image-2.png" alt="Alt text" />
以下的区分只要是为了向下兼容
<img src="8086-assembly/image-3.png" alt="Alt text" /></p>
<h2 id="指令"><a class="header" href="#指令">指令</a></h2>
<p><img src="8086-assembly/image-4.png" alt="Alt text" />
这里需要记住位的概念
<img src="8086-assembly/image-5.png" alt="例子" />
比如上面这个例子，是怎么计算的</p>
<p>然后还需要知道，AL和AH之间也不互相影响
<img src="8086-assembly/image-6.png" alt="Alt text" /></p>
<h2 id="操作对象一致性"><a class="header" href="#操作对象一致性">操作对象一致性</a></h2>
<p><img src="8086-assembly/image-7.png" alt="Alt text" />
这里对于初学者需要特别注意</p>
<h2 id="监测点21"><a class="header" href="#监测点21">监测点2.1</a></h2>
<ol>
<li></li>
</ol>
<div class="table-wrapper"><table><thead><tr><th>题</th><th>答案</th></tr></thead><tbody>
<tr><td>mov ax,62627</td><td>AX=F4A3H</td></tr>
<tr><td>mov ah,31H</td><td>AX=31A3H</td></tr>
<tr><td>mov al,23H</td><td>AX=3123H</td></tr>
<tr><td>add ax,ax</td><td>AX=6246H</td></tr>
<tr><td>mov bx,826CH</td><td>BX=826CH</td></tr>
<tr><td>mov cx,ax</td><td>CX=6246H</td></tr>
<tr><td>mov ax,bx</td><td>AX=826CH</td></tr>
<tr><td>add ax,bx</td><td>AX=04D8H</td></tr>
<tr><td>mov al,bh</td><td>AX=0482H</td></tr>
<tr><td>mov ah,bl</td><td>AX=6C82H</td></tr>
<tr><td>add ah,ah</td><td>AX=D882H</td></tr>
<tr><td>add al,6</td><td>AX=D888H</td></tr>
<tr><td>add al,al</td><td>AX=D810H</td></tr>
<tr><td>mov ax,cx</td><td>AX=6246H</td></tr>
<tr><td>2.</td><td></td></tr>
</tbody></table>
</div>
<pre><code class="language-8086 assembly">mov ax,2H
add ax,ax
add ax,ax
add ax,ax
</code></pre>
<h2 id="物理地址"><a class="header" href="#物理地址">物理地址</a></h2>
<p>唯一的地址是物理地址</p>
<p><img src="8086-assembly/image-8.png" alt="Alt text" /></p>
<h2 id="段地址偏移地址"><a class="header" href="#段地址偏移地址">段地址、偏移地址</a></h2>
<p>都是16位，最后合成20位</p>
<p><img src="8086-assembly/image-9.png" alt="Alt text" /></p>
<p>段地址*16+偏移地址=物理地址</p>
<h3 id="段的理解"><a class="header" href="#段的理解">段的理解</a></h3>
<p>并没有真正的段</p>
<p>同时，一个段最大是64KB</p>
<h2 id="监测点22"><a class="header" href="#监测点22">监测点2.2</a></h2>
<ol>
<li>10H到1000H</li>
<li>1001H 2000H</li>
<li>小于1001H或者大于2000H即可</li>
</ol>
<h2 id="段寄存器"><a class="header" href="#段寄存器">段寄存器</a></h2>
<p>CS DS SS ES</p>
<h3 id="cs-ip"><a class="header" href="#cs-ip">CS IP</a></h3>
<p>CS是段寄存器</p>
<p>8086有四个段寄存器：CS DS SS ES</p>
<p>CS是代码段寄存器，IP为指令指针寄存器（偏移地址），组合起来是CPU要执行的指令的地址</p>
<p>CS:IP指向的内容当作当前指令执行</p>
<h4 id="工作流程"><a class="header" href="#工作流程">工作流程</a></h4>
<ol>
<li>从 CS:IP 指向的内存单元读取指令，读取的指令进入指令缓冲器:</li>
<li>IP=IP+所读取指令的长度，从而指向下一条指令</li>
<li>执行指令。转到步骤(1)，重复这个过程。</li>
</ol>
<h4 id="改变值"><a class="header" href="#改变值">改变值</a></h4>
<p>无法使用MOV直接操作，但是可以使用JMP间接操作</p>
<p><strong>JMP 段地址：偏移地址</strong></p>
<p>比如jmp 2AE3:3;CS=2AE3H,IP=0003H</p>
<p><strong>若想仅修改 P 的内容，可用形如“jmp 某一合法寄存器”的指令完成</strong></p>
<h3 id="监测点23"><a class="header" href="#监测点23">监测点2.3</a></h3>
<p>四次，三条指令就三次，JMP一次，四次
IP=0000H</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字与字节"><a class="header" href="#字与字节">字与字节</a></h1>
<p>QWORD DWORD WORD BYTE bit</p>
<p>内存单元，字单元</p>
<p>低地址存低字节，高地址存高字节</p>
<p>这就是小段存储</p>
<h1 id="dsaddr"><a class="header" href="#dsaddr">DS:[ADDR]</a></h1>
<p>mov al,[0]
其中[0]的意思就是编译地址是0处的内容。</p>
<p>一般形式是：寄存器:[addr]</p>
<p>如果没有寄存器，默认 ds:[addr]</p>
<p>8086CPU一次可以传送16位数据</p>
<p><img src="8086-assembly/image-10.png" alt="Alt text" />
<img src="8086-assembly/image-11.png" alt="Alt text" /></p>
<p>事实上，只有内存与内存之间不能直接操作。</p>
<h3 id="监测点31"><a class="header" href="#监测点31">监测点3.1</a></h3>
<pre><code>(1)
AX=2662H
BX=E626H
AX=E626H
AX=2662H
BX=D6E6H
AX=FD48H
AX=2C14H
AX=0000H
AX=00E6H
BX=0000H
BX=0026H
AX=000CH
(2)
CS=2000H,IP=0,DS=1000H
AX=0,BX=0

mov ax,6622H
CS=2000H IP=3 DS=1000H AX=6622H BX=0000H
jmp 0ff0:0100
CS=0ff0H IP=0100 DS=1000H AX=6622H BX=0000H
mov ax,2000H
CS=0ff0H IP=0103 DS=1000H AX=2000H BX=0000H
mov ds,ax
CS=0ff0H IP=0105 DS=2000H AX=2000H BX=0000H
mov ax,[0008]
CS=0ff0H IP=0108 DS=2000H AX=C389H BX=0000H
mov ax,[0002]
CS=0ff0H IP=010B DS=2000H AX=EA66H BX=0000H
(3)
数据和程序在计算机中都是以二进制的形式存放的，
在区别程序和数据时，关键是看段地址，如果段地址是ds
段，说明该内存存放的是数据，如果段地址是cs段，说明该内存
存放的是指令。



</code></pre>
<h1 id="栈"><a class="header" href="#栈">栈</a></h1>
<p>PUSH入栈</p>
<p>POP出栈</p>
<p>都是以字为单位的</p>
<p>比如push ax就是把ax的内容放到栈中</p>
<h2 id="sssp"><a class="header" href="#sssp">SS:SP</a></h2>
<p>SS:SP存放了栈顶的地址</p>
<p>push ax</p>
<ol>
<li>sp=sp-2</li>
<li>ax中的内容放入栈</li>
</ol>
<h2 id="操作内容"><a class="header" href="#操作内容">操作内容</a></h2>
<p>push pop可以操作 寄存器、段寄存器、内存单元</p>
<h2 id="stack-overflow"><a class="header" href="#stack-overflow">Stack Overflow</a></h2>
<p>危险的情况，千万小心。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="伪指令"><a class="header" href="#伪指令">伪指令</a></h1>
<p>伪指令没有对应的机器码，是编译器来执行伪指令</p>
<h3 id="segment-ends"><a class="header" href="#segment-ends">segment ends</a></h3>
<p>segment和ends组合使用，用于定义一个段</p>
<p>格式：</p>
<pre><code>段名:segment
·
·
·
段名:ends
</code></pre>
<h3 id="end"><a class="header" href="#end">end</a></h3>
<p>end是一个汇编程序的结束标记</p>
<p>如果碰到了end，就结束源程序的编译</p>
<h3 id="assume"><a class="header" href="#assume">assume</a></h3>
<p>含义是“假设”，假设某一段寄存器和程序中的某一个segment ends定义的段相关联。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loop"><a class="header" href="#loop">loop</a></h1>
<p>循环指令，要有标号</p>
<p><code>CX</code>是存放判定条件的</p>
<p>inc、dec：自增、自减</p>
<p>[bx]表示bx之中存储的内容当作偏移地址</p>
<p>DX 累加器</p>
<p><strong>在汇编源程序之中，数据不能以字母开头。</strong></p>
<p>Debug的<code>g</code>命令,可以直接执行之前的所有汇编命令</p>
<p><code>p</code>命令，可以直接执行完循环</p>
<h2 id="masm和debug的不同"><a class="header" href="#masm和debug的不同">MASM和Debug的不同</a></h2>
<p><img src="8086-assembly/image-12.png" alt="Alt text" /></p>
<h2 id="回到标题"><a class="header" href="#回到标题">回到标题</a></h2>
<p>类型不匹配，怎么解决？</p>
<p>把8位的先赋值到16位寄存器之中，然后再操作</p>
<p>一般我们如果需要向内存写入数据，可以使用0:200~0:2ff的256个字节的空间。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="段"><a class="header" href="#段">段</a></h1>
<p>在assume之中把各个段定义然后分开存储，清晰</p>
<p>所有的空间应该有系统为我们分配</p>
<p>伪指令end</p>
<h2 id="监测点61"><a class="header" href="#监测点61">监测点6.1</a></h2>
<p>第一问</p>
<pre><code>assume cs:codesg
codesg segment

	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h;ip为0,2,4,6,8..

start:	mov ax,0
		mov ds,ax;ds设置为0
		mov bx,0

		mov cx,8;8次循环
s:		mov ax,[bx]
    	___;填写的地方,应该填写`mov cs:[bx],ax`
		add bx,2
		loop s

		mov ax,4c00h
		int 21h

codesg ends
end start

</code></pre>
<p>第二问</p>
<pre><code>assume cs:codesg

codesg segment
	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
	dw 0,0,0,0,0,0,0,0,0,0

start:	mov ax,___;应该填cs,因为栈空间被放到了程序的开头进行声明
		mov ss,ax;设置ss的值
		mov sp,___;设置sp的值,应该填24h,因为前面还有8个字,即16字节,栈顶是往高位 数,而且栈里面有10个字节

		mov ax,0;
		mov ds,ax;ds为0
		mov bx,0;bx用做下标
		mov cx,8;循环8次

s:		push [bx];把0:[bx]入栈
		pop cs:___;这里应该赋值给cs:[bx],所以填写[bx]
		add bx,2
		loop s

		mov ax,4c00H
		int 21h

codesg ends
end start
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="与或非"><a class="header" href="#与或非">与或非</a></h1>
<p>与或非的概念，比较简单</p>
<h1 id="字符串"><a class="header" href="#字符串">字符串</a></h1>
<p><img src="8086-assembly/image-13.png" alt="Alt text" />
这里的db是指一个字符一个byte</p>
<h1 id="大小写转换"><a class="header" href="#大小写转换">大小写转换</a></h1>
<p>ascii码之中，小写=大写+20H
<img src="8086-assembly/image-14.png" alt="Alt text" />
这里主要就是这个第五位(20H的2，即32)
<img src="8086-assembly/image-15.png" alt="Alt text" /></p>
<p>核心就是，转大写：</p>
<pre><code>and al,11011111B
</code></pre>
<p>转小写</p>
<pre><code>or al,00100000B
</code></pre>
<h1 id="bxidata"><a class="header" href="#bxidata">[bx+idata]</a></h1>
<p>[bx+idata]表示一个内存单元，偏移地址为(bx)+idata</p>
<p>有以下几种写法</p>
<pre><code>mov ax,[200+bx]
mov ax,[bx+200]
mov ax,200[bx]
mov ax,[bx].200
</code></pre>
<p>[bx+idata]可以进行类似数组的处理</p>
<h1 id="si和di"><a class="header" href="#si和di">SI和DI</a></h1>
<p>和bx功能接近的寄存器，但不能分为两个八位的寄存器使用</p>
<p>分别表示源和目的</p>
<p>[bx+si]</p>
<p>[bx+si+idata]可表示以下形式</p>
<pre><code>mov ax,[bx+si+200]
mov ax,[si+bx+200]
mov ax,[200+bx+si]
mov ax,200[bx][si]
mov ax,[bx].200[si]
mov ax,[bx][si].200
</code></pre>
<h1 id="不同寻址方式的灵活应用"><a class="header" href="#不同寻址方式的灵活应用">不同寻址方式的灵活应用</a></h1>
<p><img src="8086-assembly/image-16.png" alt="Alt text" /></p>
<h1 id="二重循环"><a class="header" href="#二重循环">二重循环</a></h1>
<p>用dx存cx,内层循环结束后，把dx赋值给cx。</p>
<p>如果没有富余的寄存器怎么办？存在内存空间之中即可！</p>
<p>内存需要记忆地址，怎么办？<strong>使用栈！</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bx-si-di-bp"><a class="header" href="#bx-si-di-bp">bx si di bp</a></h1>
<p>只有这四个寄存器用于寻址</p>
<p>同时，bi不能与bp相加，si和di相加</p>
<p>bi\bp和si\di可以相加</p>
<p><img src="8086-assembly/image-17.png" alt="Alt text" /></p>
<p><strong>只要有bp,默认段为ss!</strong></p>
<h1 id="数据位置"><a class="header" href="#数据位置">数据位置</a></h1>
<p>立即数、寄存器、短地址和偏移地址</p>
<h1 id="寻址方式"><a class="header" href="#寻址方式">寻址方式</a></h1>
<ol>
<li>直接寻址</li>
<li>寄存器间接寻址</li>
<li>寄存器相对寻址</li>
<li>基址变址寻址</li>
<li>相对基址变址寻址</li>
</ol>
<p><img src="8086-assembly/image-18.png" alt="Alt text" /></p>
<h1 id="指令到底有多长"><a class="header" href="#指令到底有多长">指令到底有多长？</a></h1>
<p>引入了X prt操作符说明，
X可以是word byte，
例如</p>
<pre><code>mov word ptr ds:[0],1
inc byte ptr [bx]
add word ptr [bp],2
</code></pre>
<p>push 和 pop永远是对word操作</p>
<h1 id="寻址方式的综合应用"><a class="header" href="#寻址方式的综合应用">寻址方式的综合应用</a></h1>
<p><img src="8086-assembly/image-19.png" alt="Alt text" />
<img src="8086-assembly/image-20.png" alt="Alt text" /></p>
<p>从汇编可以感受出来，结构体也就是一段内存空间而已，没什么太深的东西。</p>
<p>我们可以看到，8086CPU 提供的如[bx+si+idata]的寻址方式为结构化数据的处理提供了方便。使得我们可以在编程的时候，从结构化的角度去看待所要处理的数据。从上面可以看到，一个结构化的数据包含了多个数据项，而数据项的类型又不相同，有的是字型数据，有的是字节型数据，有的是数组(字符串)。一般来说，我们可以用[bx+idata+si]的方式来访问结构体中的数据。用 bx 定位整个结构体，用idata 定位结构体中的某一个数据项用 si 定位数组项中的每个元素。为此，汇编语言提供了更为贴切的书写方式，如:[bx].idata、[bx].idata[si] .</p>
<h1 id="div指令"><a class="header" href="#div指令">Div指令</a></h1>
<ol>
<li>除数有8和16位两种，存在一个寄存器或者内存单元之中</li>
<li>被除数，存在AX或者AX和DX之中。DX存高16位，AX存低16位。只有32位/16位和16位/8位。</li>
<li>结果，如果除数为8位，AL存商，AH存余数。如果除数为16位，AX存商，DX存余数。</li>
</ol>
<h1 id="伪指令dd"><a class="header" href="#伪指令dd">伪指令dd</a></h1>
<p>定义double word</p>
<h1 id="伪指令dup"><a class="header" href="#伪指令dup">伪指令dup</a></h1>
<p>是一个操作符，用来进行数据的重复</p>
<pre><code>db 3 dup (0)
</code></pre>
<p>定义了三个字节，值都是0.相当于</p>
<pre><code>db 0,0,0
</code></pre>
<p><strong>使用方法： dd 重复的次数 dup （重复的数据）</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="转移指令"><a class="header" href="#转移指令">转移指令</a></h1>
<p>可以修改IP或CS和IP的，统称为转移指令。</p>
<p>8086CPU 的转移行为有以下几类。</p>
<ul>
<li>只修改P 时，称为段内转移，比如: jmp ax。</li>
<li>同时修改 CS 和P 时，称为段间转移，比如: jmp 1000:0</li>
</ul>
<p>由于转移指令对 IP 的修改范围不同，段内转移又分为: 短转移和近转移</p>
<ul>
<li>短转移 IPP 的修改范围为-128~127.</li>
<li>近转移 IP 的修改范围为-32768~32767。</li>
</ul>
<p>8086CPU 的转移指令分为以下几类</p>
<ul>
<li>无条件转移指令(如: jmmp)</li>
<li>条件转移指令</li>
<li>循环指令(如: loop)</li>
<li>过程</li>
<li>中断</li>
</ul>
<h2 id="offset"><a class="header" href="#offset">offset</a></h2>
<p>取标号的偏移地址</p>
<h2 id="jmp"><a class="header" href="#jmp">jmp</a></h2>
<p>无条件跳转指令，只修改IP，也可以同时修改CS和IP</p>
<p>jmp必须给出的信息：</p>
<ol>
<li>转移的目的地址</li>
<li>转移的距离</li>
</ol>
<h2 id="jmp-short"><a class="header" href="#jmp-short">jmp short</a></h2>
<p>段内短转移，IP属于-128到127</p>
<p>CPU在执行jmp指令的时候并不需要转移的目的地址</p>
<p><img src="8086-assembly/image-21.png" alt="Alt text" /></p>
<h2 id="jmp-near-ptr"><a class="header" href="#jmp-near-ptr">jmp near ptr</a></h2>
<p><img src="8086-assembly/image-22.png" alt="Alt text" /></p>
<h2 id="jmp-far-ptr"><a class="header" href="#jmp-far-ptr">jmp far ptr</a></h2>
<p><img src="8086-assembly/image-23.png" alt="Alt text" /></p>
<h2 id="监测点91"><a class="header" href="#监测点91">监测点9.1</a></h2>
<ol>
<li>dw 0,0.0</li>
<li>offset start; cs</li>
<li>CS=0006,IP=00BE</li>
</ol>
<h2 id="jcxz"><a class="header" href="#jcxz">jcxz</a></h2>
<p>有条件跳转，所有的有条件跳转指令，都是短转移。</p>
<h2 id="监测点92"><a class="header" href="#监测点92">监测点9.2</a></h2>
<pre><code>mov ch,0
mov cl,[bx]
jxcz ok
inc bx
</code></pre>
<h2 id="loop-1"><a class="header" href="#loop-1">loop</a></h2>
<p>之前已经讲过了</p>
<h2 id="监测点93"><a class="header" href="#监测点93">监测点9.3</a></h2>
<pre><code>inc cx
</code></pre>
<h2 id="自动监测"><a class="header" href="#自动监测">自动监测</a></h2>
<p>如果转移的范围超过了边界，编译器会报错。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ch10"><a class="header" href="#ch10">ch10</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ch11"><a class="header" href="#ch11">ch11</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ch12"><a class="header" href="#ch12">ch12</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="两个指令"><a class="header" href="#两个指令">两个指令</a></h1>
<p>ADC SBB
<img src="8086-assembly/image-32.png" alt="Alt text" /></p>
<p><img src="8086-assembly/image-33.png" alt="Alt text" /></p>
<p><img src="8086-assembly/image-34.png" alt="Alt text" /></p>
<h1 id="cmp"><a class="header" href="#cmp">CMP</a></h1>
<p><img src="8086-assembly/image-35.png" alt="Alt text" /></p>
<p>作用是改变FLAG</p>
<h1 id="跳转指令"><a class="header" href="#跳转指令">跳转指令</a></h1>
<p><img src="8086-assembly/image-36.png" alt="Alt text" /></p>
<p>j是JUMP，后面的字母是：</p>
<p><img src="8086-assembly/image-37.png" alt="Alt text" /></p>
<h2 id="监测点113"><a class="header" href="#监测点113">监测点11.3</a></h2>
<ol>
<li></li>
</ol>
<pre><code>mov ax,0f000h
mov ds,ax

mov bx,0
mov dx,0
mov cx,32

s:
  mov al,[bx]
  cmp al,32
  jb s0
  cmp al,128
  ja s0
  inc dx

s0:
  inc bx
  loop s


</code></pre>
<ol start="2">
<li></li>
</ol>
<pre><code>mov ax,0f000h
mov dx,ax

mov bx,0
mov dx,0
mov cx,32
s:
  mov al,[bx]
  cmp al,32
  jna s0
  cmp al,128
  jnb s0
  inc dx

s0:
  inc bx
  loop s
</code></pre>
<h1 id="df-和-串指令"><a class="header" href="#df-和-串指令">DF 和 串指令</a></h1>
<p><img src="8086-assembly/image-38.png" alt="Alt text" /></p>
<h2 id="串指令"><a class="header" href="#串指令">串指令</a></h2>
<p>movsb movsw</p>
<p>把ds:si的内容复制到es:di之中，然后si di同时加或者减一</p>
<p>与rep配合使用</p>
<pre><code>rep movsb
</code></pre>
<h2 id="如何设置df"><a class="header" href="#如何设置df">如何设置df?</a></h2>
<p><img src="8086-assembly/image-39.png" alt="Alt text" /></p>
<h1 id="pushf--popf"><a class="header" href="#pushf--popf">PUSHF &amp; POPF</a></h1>
<p>把FLAGS进行入栈和出栈操作</p>
<h2 id="检测点114"><a class="header" href="#检测点114">检测点11.4</a></h2>
<pre><code>mov ax,0
push ax
popf
mov ax,0fff0h
add ax,0010h
pushf
pop ax
and al,11000101B
and ah,00001000B
</code></pre>
<p>第三条语句 popf 将栈中数据 0 弹出，并送入标志寄存器，此时标志位全部置零。
第四 / 五条语句，加法运算，0FFF0H + 0010H。对于有符号数的计算而言，(-16) + (16) = 0，无溢出，OF=0；对于无符号数的计算而言，(65520) + (16) = 65536，有向更高位的进位，CF=1。且 ZF=0，PF=1。
语句 pushf 将标志寄存器的内容入栈，此时标志寄存器的内容为 0000 0000 0100 0101，则后续出栈后 (AX)=0045H。
and al,11000101B 进行按位与运算，结果为 (AL)=0100 0101=45H；and ah,00001000B 进行按位与运算，结果为 (AH)=0000 0000H。所以，最终 (AX)=0045H。</p>
<h1 id="debug之中的表示"><a class="header" href="#debug之中的表示">debug之中的表示</a></h1>
<p><img src="8086-assembly/image-40.png" alt="Alt text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内中断"><a class="header" href="#内中断">内中断</a></h1>
<p>中断，一种需要立即去执行的特殊信息。</p>
<h2 id="内中断的产生"><a class="header" href="#内中断的产生">内中断的产生</a></h2>
<p><img src="8086-assembly/image-41.png" alt="Alt text" /></p>
<p><img src="8086-assembly/image-42.png" alt="Alt text" /></p>
<p><img src="8086-assembly/image-43.png" alt="Alt text" /></p>
<h2 id="中断处理程序"><a class="header" href="#中断处理程序">中断处理程序</a></h2>
<p>收到中断信息，如何处理，由自己编程。</p>
<p><img src="8086-assembly/image-44.png" alt="Alt text" /></p>
<h2 id="中断向量表"><a class="header" href="#中断向量表">中断向量表</a></h2>
<p>中断向量表就是存中断向量的，存中断处理程序的入口</p>
<p><img src="8086-assembly/image-45.png" alt="Alt text" /></p>
<p>中断向量表在内存中存放，对于 8086PC 机，中断向量表指定放在内存地址 0 处。内存 0000:0000 到 0000:03EF 的 1024 个单元中存放着中断向量表。</p>
<p>那么在中断向量表中，一个表项占多大的空间呢?一个表项存放一个中断向量，也就是一个中断处理程序的入口地址，对于 8086CPU，这个入口地址包括段地址和偏移地址，所以一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址。</p>
<h2 id="监测点121"><a class="header" href="#监测点121">监测点12.1</a></h2>
<p>(1)用debug查看内存，情况如下：
0000:0000 68 10 A7 00 8B 01 70 00-16 00 9D 03 8B 01 70 00</p>
<p>解释：一个表项存放一个中断向量，也就是一个中断处理程序的入口地址，这个入口地址包括段地址和偏移地址，一个表项占两个字，高地址存放段地址，低地址存放偏移地址。所以可得</p>
<pre><code>  0号：00A7：1068
  1号：0070：108B
  2号：039D：0016
  3号：0070：108B
</code></pre>
<p>(2)
存储N号中断源对应的中断处理程序入口的偏移地址的内存单元的地址为： 4N
存储N号中断源对应的中断处理程序入口的段地址的内存单元的地址为： 4N+2</p>
<h2 id="中断过程"><a class="header" href="#中断过程">中断过程</a></h2>
<p><img src="8086-assembly/image-46.png" alt="Alt text" /></p>
<p><img src="8086-assembly/image-47.png" alt="Alt text" /></p>
<h2 id="中断处理程序和iret"><a class="header" href="#中断处理程序和iret">中断处理程序和iret</a></h2>
<p><img src="8086-assembly/image-48.png" alt="Alt text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="int指令"><a class="header" href="#int指令">int指令</a></h1>
<p><img src="8086-assembly/image-49.png" alt="Alt text" /></p>
<h1 id="dos-bios"><a class="header" href="#dos-bios">DOS BIOS</a></h1>
<p><img src="8086-assembly/image-51.png" alt="Alt text" /></p>
<p>操作系统的东东。。。</p>
<p><img src="8086-assembly/image-50.png" alt="Alt text" /></p>
<h1 id="一直以来写的东西"><a class="header" href="#一直以来写的东西">一直以来写的东西</a></h1>
<p><img src="8086-assembly/image-52.png" alt="Alt text" /></p>
<p>终于知道这两句是啥了</p>
<h1 id="监测点"><a class="header" href="#监测点">监测点</a></h1>
<p>直接放个别人的<a href="https://blog.csdn.net/shaco_/article/details/105646748">链接</a>,<a href="https://blog.csdn.net/shaco_/article/details/105659519">13.2</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="端口"><a class="header" href="#端口">端口</a></h1>
<p><img src="8086-assembly/image-53.png" alt="Alt text" /></p>
<p>in out对端口进行读或写，一个字节</p>
<p><strong>只能用ax或者al!</strong></p>
<h2 id="监测点141"><a class="header" href="#监测点141">监测点14.1</a></h2>
<ol>
<li>in al,2h</li>
<li>两条命令</li>
</ol>
<pre><code>mov al,0
out 20h,al
</code></pre>
<h1 id="左移右移"><a class="header" href="#左移右移">左移右移</a></h1>
<p>shl shr</p>
<h2 id="监测点142"><a class="header" href="#监测点142">监测点14.2</a></h2>
<pre><code>shl ax,1
mov dx,ax
shl ax,1
shl ax,1
add ax,dx
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="其他-1"><a class="header" href="#其他-1">其他</a></h1>
<p>外中断</p>
<p>键盘是咋回事儿建议看书</p>
<h2 id="监测点15"><a class="header" href="#监测点15">监测点15</a></h2>
<p>只有pushf和call</p>
<h2 id="直接定址表"><a class="header" href="#直接定址表">直接定址表</a></h2>
<p>标号也可以表示长度，很有意思</p>
<p>数据标号</p>
<h2 id="检测点16"><a class="header" href="#检测点16">检测点16</a></h2>
<p><a href="https://blog.csdn.net/Skies_/article/details/124583091">看这个参考吧，不想写了</a></p>
<h2 id="其他-2"><a class="header" href="#其他-2">其他</a></h2>
<p>确实得结合书来看了。</p>
<h2 id="最后的综合研究"><a class="header" href="#最后的综合研究">最后的综合研究</a></h2>
<p>对学过编译的人来说，有点儿无聊，适合初学者探索。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="记录了所有实验的内容"><a class="header" href="#记录了所有实验的内容">记录了所有实验的内容</a></h1>
<p>前面的部分实验由于仅仅是调试和学习，因此不记录具体细节。</p>
<p>所有编程作业都给出完整代码。</p>
<h1 id="实验环境"><a class="header" href="#实验环境">实验环境</a></h1>
<p>前面的实验基本上都可以在windows xp虚拟机上工作。</p>
<p>后面有一些需要用到dos的特性的，用了一个网友的环境，配的很好，不过没有找到最早的出处。关于那个环境的一切都在<code>vmdos71.rar</code>这个文件之中，包括如何使用和安装！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug"><a class="header" href="#debug">Debug</a></h1>
<p>一种Dos和windows7以前提供的调试工具，可以看寄存器内容、内存状态和机器码。</p>
<h2 id="功能"><a class="header" href="#功能">功能</a></h2>
<p>用 Debug 的 R 命令查看、改变 CPU 寄存器的内容;
用 Debug 的 D 命令查看内存中的内容:
用 Debug 的 E 命令改写内存中的内容;
用 Debug 的 U 命令将内存中的机器指令翻译成汇编指令:
用 Debug 的 T 命令执行一条机器指令;
用 Debug 的 A 命令以汇编指令的格式在内存中写入一条机器指令</p>
<h1 id="开始实验"><a class="header" href="#开始实验">开始实验</a></h1>
<p>我所使用的是吾爱破解XP虚拟机</p>
<p>首先输入r，查看各寄存器状态
<img src="Labs/image.png" alt="-r" /></p>
<p>基本的查看和改变寄存器状态
<img src="Labs/image-1.png" alt="基本内容" /></p>
<p>然后是使用d命令</p>
<pre><code>d 段地址:偏移地址
</code></pre>
<p><img src="Labs/image-2.png" alt="-d" /></p>
<p>可惜我这里什么也没看到</p>
<pre><code>d 段地址:起始偏移地址 结尾偏移地址
</code></pre>
<p><img src="Labs/image-3.png" alt="读取内容" /></p>
<p>e 命令可以改变数据内容
<img src="Labs/image-4.png" alt="-e" /></p>
<p>这里把前三个FF改成41,也就是十进制之下的65（A的ascii码）了</p>
<p>也可以按照提示模式逐步改写</p>
<p>u命令可以查看机器码对应的汇编指令，t命令可以执行</p>
<p>a命令则可以以汇编代码形式写入</p>
<h3 id="问题1"><a class="header" href="#问题1">问题1</a></h3>
<pre><code>mov ax,4E20
add bx,1416
mov bx,2000
add ax,bx
mov bx,ax
add ax,bx
mov ax,001A
mov bx,0026
add al,bl
add ah,bl
add bh,al
mov ah,0
add al,bl
add al,9c
</code></pre>
<p><img src="Labs/image-5.png" alt="Alt text" />
结果：</p>
<pre><code>机器码				汇编指令					运行结果		CS:IP
b8 20 43			mov ax,4E20H			ax=4E20		1000:0003
05 16 14			add ax,1416H			ax=6236		1000:0007
bb 00 20			mov bx,2000H			bx=2000		1000:000A
01 d8				add ax,bx				ax=8236		1000:000C
89 c3				mov bx,ax				bx=8236		1000:000E
01 d8				add ax,bx				ax=046C		1000:0000
b8 1a 00			mov ax,001AH			ax=001A		1000:0013
bb 26 00			mov bx,0026H			bx=0026		1000:0016
00 d8				add al,bl				ax=0040		1000:0018
00 dc				add ah,bl				ax=2640		1000:001A
00 c7				add bh,al				bx=4026		1000:001C
b4 00				mov ah,0				ax=0040		1000:001E
00 d8				add al,bl				ax=0066		1000:0020
04 9c				add al,9cH              ax=0002	    1000:0022

</code></pre>
<h3 id="问题2"><a class="header" href="#问题2">问题2</a></h3>
<p><img src="Labs/image-6.png" alt="Alt text" />
关键在于知道写在哪，那个JMP需要跳到add ax,ax这一句，然后反复加</p>
<h3 id="问题3"><a class="header" href="#问题3">问题3</a></h3>
<p><img src="Labs/image-7.png" alt="日期" />
找到了，但是改不了，因为ROM是只读存储器</p>
<h3 id="问题4"><a class="header" href="#问题4">问题4</a></h3>
<p><img src="Labs/image-8.png" alt="Alt text" />
输入以后有这些玩意儿</p>
<p>在8086PC机中A0000~BFFFF内存是显存地址空间。向地址A0000~BFFFF的内存单元中写数据，就是向显存中写入数据，这些数据会被显示卡输出到显示器上。</p>
<p>本题之中，在一个字(16位)中，低位字节决定了图案，高位字节决定了颜色</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="段-1"><a class="header" href="#段-1">段</a></h1>
<p>在修改段寄存器的指令执行时，下一条命令会紧接着执行</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="观察栈和psp"><a class="header" href="#观察栈和psp">观察栈和PSP</a></h1>
<p>还是比较简单的。</p>
<p>PSP的头两个字节是CD20</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab4"><a class="header" href="#lab4">lab4</a></h1>
<h2 id="向内存0200023f依次传递数据063"><a class="header" href="#向内存0200023f依次传递数据063">向内存0:200~0:23F依次传递数据0~63</a></h2>
<pre><code>assume cs:code
code segment
    mov ax,0020H
    mov ds,ax
    mov bx,0000H
    mov cx,0040H
s:  mov [bx],bl
    inc bl
    loop s
    mov ax,4c00H
    int 21H
code ends
end
</code></pre>
<p>这里，bl是否使用用无所谓，因为是小段存储。</p>
<h2 id="向内存0200023f依次传递数据063只允许使用九条指令包括mov-ax4c00h和int-21h"><a class="header" href="#向内存0200023f依次传递数据063只允许使用九条指令包括mov-ax4c00h和int-21h">向内存0:200~0:23F依次传递数据0~63，只允许使用九条指令，包括mov ax,4c00h和int 21h</a></h2>
<p>代码与上一题相同</p>
<p>最重要的就是复用寄存器。</p>
<p><img src="Labs/image-9.png" alt="Alt text" />
最后结果，可见实验成功。</p>
<h2 id="下面的程序的功能是将mov-ax4c00h之前的指令复制到内存00200处补全程序上机调试跟踪运行结果"><a class="header" href="#下面的程序的功能是将mov-ax4c00h之前的指令复制到内存00200处补全程序上机调试跟踪运行结果">下面的程序的功能是将“mov ax,4c00h”之前的指令复制到内存0~0:200处，补全程序。上机调试，跟踪运行结果。</a></h2>
<pre><code>assume cs:code

code segment
	mov ax,cs
	mov ds,ax
	mov ax,0020h
	mov es,ax
	mov bx,0
	mov cx,23

s:
	mov al,[bx]
	mov es:[bx],al
	inc bx
	loop s
	mov ax,4c00h
	int 21h
code ends
end
</code></pre>
<p>提示：
(1)复制的是什么？从哪里到哪里？
答：复制的是程序的指令，从“mov ax,cs”开始到“loop s”。
(2)复制的什么？有多少个字节？你如何知道要复制的字节的数量
复制的是程序的指令，先运行程序，根据CX寄存器的值知道程序的长度(字节)。然后在减去从“mov ax,4c00h“指令开始的程序长度。</p>
<p><img src="Labs/image-10.png" alt="Alt text" />
本题的难度在于不知道机器码有长，可以随便填一个数先进去看然后再改</p>
<p>可以发现复制成功
<img src="Labs/image-11.png" alt="Alt text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实验五"><a class="header" href="#实验五">实验五</a></h1>
<h2 id="第一问"><a class="header" href="#第一问">第一问</a></h2>
<pre><code>assume cs:code,ds:data,ss:stack
data segment
    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
data ends

stack segment
    dw 0,0,0,0,0,0,0,0
stack ends

code segment
start:  mov ax,stack
        mov ss,ax
        mov sp,16

        mov ax,data
        mov ds,ax

        push ds:[0]
        push ds:[2]
        pop ds:[2]
        pop ds:[0]

        mov ax,4c00h
        int 21h
code ends
end start
</code></pre>
<ol>
<li>data没有变化</li>
<li>CS=0B3B,SS=0B3A ,DS=0B39</li>
<li>程序加载后，code段地址设为X，则data段地址为X-2,stack段的段地址为X-1.</li>
</ol>
<h2 id="第二问"><a class="header" href="#第二问">第二问</a></h2>
<pre><code>assume cs:code,ds:data,ss:stack
data segment
    dw 0123h,0456h
data ends

stack segment
    dw 0,0
stack ends

code segment
start:  mov ax,stack
        mov ss,ax
        mov sp,16

        mov ax,data
        mov ds,ax

        push ds:[0]
        push ds:[2]
        pop ds:[2]
        pop ds:[0]

        mov ax,4c00h
        int 21h
code ends
end start
</code></pre>
<p>本题的重点在于：数据段和栈段在程序加载后实际占据的空间都是以16个字节为单位的。程序中只给出了前两个字数据，其余空间都用0填充。</p>
<ol>
<li>data不变</li>
<li>CS=0B3B,SS=0B3A ,DS=0B39</li>
<li>程序加载后，code段地址设为X，则data段地址为X-2,stack段的段地址为X-1.</li>
<li>实际占有的空间为：$$(N+15)/16*16$$</li>
</ol>
<h2 id="第三问"><a class="header" href="#第三问">第三问</a></h2>
<pre><code>assume cs:code,ds:data,ss:stack

code segment
start:  mov ax,stack
        mov ss,ax
        mov sp,16

        mov ax,data
        mov ds,ax

        push ds:[0]
        push ds:[2]
        pop ds:[2]
        pop ds:[0]

        mov ax,4c00h
        int 21h
code ends

data segment
    dw 0123h,0456h
data ends

stack segment
    dw 0,0
stack ends
end start
</code></pre>
<ol>
<li>data不变</li>
<li>CS=0B39,SS=0B3D ,DS=0B3C</li>
<li>程序加载后，code段地址设为X，则data段地址为X+3,stack段的段地址为X+4.</li>
</ol>
<h2 id="第四问"><a class="header" href="#第四问">第四问</a></h2>
<p>只有三，因为不指定会从第一个段开始。</p>
<h2 id="第五问"><a class="header" href="#第五问">第五问</a></h2>
<p>这里，不能把c当栈用，下一题可以</p>
<pre><code>assume cs:code
a segment
    db 1,2,3,4,5,6,7,8
a ends

b segment
    db 1,2,3,4,5,6,7,8
b ends

c segment
    db 0,0,0,0,0,0,0,0
c ends

code segment
start:
        mov ax,c
        mov ss,ax

        mov cx,8
        mov bx,0

    s:  mov ax,a
        mov es,ax
        mov dl,es:[bx]
        mov ax,b
        mov es,ax
        add dl,es:[bx]
        mov ss:[bx],dl
        inc bx
        loop s

        mov ax,4c00h
        int 21h
code ends
end start
</code></pre>
<p><img src="Labs/image-12.png" alt="Alt text" />
a的地址是0B39,b的地址是0B3A，c的地址是0B3B。可以看到成功了
<img src="Labs/image-13.png" alt="Alt text" />
总感觉写贼鸡儿麻烦呢。。。</p>
<h2 id="第六问"><a class="header" href="#第六问">第六问</a></h2>
<p>这个巨简单，就不停往下压栈就行。</p>
<pre><code>assume cs:code
a segment
    dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh
a ends

b segment
    dw 0,0,0,0,0,0,0,0
b ends

code segment
start:	mov ax,b
		mov ss,ax
		mov sp,10h	;拿b当栈用

		mov ax,a
		mov es,ax

		mov bx,0

		mov cx,8
s:		push es:[bx]
		add bx,2
		loop s

    	mov ax,4c00h
    	int 21h

code ends
end start
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编程"><a class="header" href="#编程">编程</a></h1>
<pre><code>assume cs:codesg,ss:stacksg,ds:datasg
stacksg segment
    dw 0,0,0,0,0,0,0,0
stacksg ends

datasg segment
    db '1. display      '
    db '2. brows        '
    db '1. replace      '
    db '1. modify       '
datasg ends

codesg segment
    start:  mov ax,stacksg
            mov ss,ax
            mov sp,16;define a stack

            mov ax,datasg
            mov ds,ax
            mov bx,0;begin at line 0

            mov cx,4
        s0: push cx
            mov si,0; column begins at 3
            mov cx,4
        s:  mov al,[bx+3+si]
            and al,11011111B
            mov [bx+3+si],al
            inc si
            loop s

            add bx,16
            pop cx
            loop s0

            mov ax,4c00H
            int 21H
codesg ends

end start
</code></pre>
<p><img src="Labs/image-14.png" alt="Alt text" /></p>
<p>看一下原始的内容，数据段在0B38
<img src="Labs/image-15.png" alt="Alt text" />
<img src="Labs/image-16.png" alt="Alt text" /></p>
<p>可以看到成功！
<img src="Labs/image-17.png" alt="Alt text" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编程-1"><a class="header" href="#编程-1">编程</a></h1>
<pre><code>assume cs:codesg,ds:table,es:data

data segment
    db '1975', '1976', '1977', '1978', '1979', '1980', '1981'
    db '1982', '1983', '1984', '1985', '1986', '1987', '1988'
    db '1989', '1990', '1991', '1992', '1993', '1994', '1995'

    dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479
    dd 140417, 197514, 345980, 590827, 803530, 1183000, 1843000
    dd 2759000, 3753000, 4649000, 5937000

    dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778, 1001, 1442, 2258
    dw 2793, 4037, 5635, 8226, 11542, 14430, 15257, 17800
data ends

table segment
    db 21 dup ('year summ ne ?? ')
table ends

codesg segment
    start:  mov ax,data
            mov es,ax               ;data绑es

            mov ax,table
            mov ds,ax               ;table绑ds,这样寻址的时候不用写段地址

            sub bx,bx
            sub si,si
            mov di,168              ;这个必须自己算一下，4*21+4*21
                                    ;这里本来想全用si，但是问题在于si加的话，一个收入是DWORD，一个人数是WORD，直接加会导致跳过一个人数，等于你1976对应的人是1977的，1977对应的人是1979的。没办法只能用新的寄存器存了

            mov cx,21
        s:  mov ax,es:[si]
            mov [bx].0h[0],ax
            mov ax,es:[si+2]
            mov [bx].0h[2],ax       ;存年份，四个byte，存两次即可

            mov ax,es:[di]
            mov [bx].10[0],ax       ;人数是字，直接存

            mov ax,es:[si+84]
            mov [bx].5[0],ax
            mov dx,es:[si+86]
            mov [bx].5[2],dx        ;收入是双字，要存两次，然后为了和后面的除法对应上，直接存dx和ax里,这里要注意小端存储
                                    ;这里可以看到，一个年份和对应的收入，其实大小都是4字节的。这样si可以一次循环内使用。

            div word ptr es:[di]    ;指明除数的长度
            mov [bx].13[0],ax

            add bx,10h
            add si,4
            add di,2
            loop s

            mov ax,4c00h
            int 21h
codesg ends
end start

</code></pre>
<p>一个看起来很烦实际上也就那么回事儿的一个破玩意儿。。。</p>
<p><img src="Labs/image-18.png" alt="Alt text" /></p>
<p>DS是0B47,查看一下</p>
<p><img src="Labs/image-19.png" alt="Alt text" /></p>
<p>这里20表示空格，别的都可以对应的上。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="分析"><a class="header" href="#分析">分析</a></h1>
<pre><code>assume cs:codesg
codesg segment
            mov ax,4c00h
            int 21h

    start:  mov ax,0
        s:  nop
            nop

            mov di,offset s
            mov si,offset s2
            mov ax,cs:[si]
            mov cs:[di],ax

        s0: jmp short s

        s1: mov ax,0
            int 21h
            mov ax,0
        s2: jmp short s1
            nop

codesg ends
end start
</code></pre>
<p>这个程序从start开始</p>
<p>先执行s</p>
<p>di之中是s的地址
si之中的s2的地址</p>
<p>cs:[di]之中存cs:[si]，也就是cs:s2的内容。</p>
<p>程序现在变成了这样。</p>
<pre><code>assume cs:codesg
codesg segment
            mov ax,4c00h
            int 21h

    start:  mov ax,0
        s:  jmp short s1

            mov di,offset s
            mov si,offset s2
            mov ax,cs:[si]
            mov cs:[di],ax

        s0: jmp short s

        s1: mov ax,0
            int 21h
            mov ax,0
        s2: jmp short s1
            nop

codesg ends
end start
</code></pre>
<p>然后执行s0，跳到s。这里需要注意，jmp short是通过计算IP来的，也就是说是把IP往下减8个单位。因此，当运行到S的jmp short s1时，实际上是把IP减少8个byte，这时正好跳回一开始的mov ax,4c00h，然后执行。因此可以顺利退出。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编程-2"><a class="header" href="#编程-2">编程</a></h1>
<h2 id="绿色"><a class="header" href="#绿色">绿色</a></h2>
<pre><code>assume cs:codesg
data segment
    db 'welcome to masm!'
    db 02h,24h,71h
data ends
codesg segment
start:
        mov ax,data
        mov es,ax
        mov ax,0B878h
        mov ds,ax
        mov bx,0

        mov cx,3
        mov bp,16
    s0: mov dx,cx
        mov cx,16
        mov si,0
        mov di,64

    s:  mov al,es:[si]
        mov [bx+di],al
        mov al,es:[bp]
        mov [bx+di+1],al
        add di,2
        inc si
        loop s

        inc bp
        mov cx,dx
        add bx,00A0h
        loop s0

        mov ax,4c00h
        int 21h
codesg ends
end start
</code></pre>
<p>结果如下：
<img src="Labs/image-20.png" alt="Alt text" /></p>
<p>不确定有没有简单的方法，我用了太多寄存器了。</p>
<p><strong>这个没那么难，但是如果想写的简单可能需要一些练习。</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实验十"><a class="header" href="#实验十">实验十</a></h1>
<h2 id="显示字符串"><a class="header" href="#显示字符串">显示字符串</a></h2>
<pre><code>; name: show_str
; func: show a string at a given position with given color
; paras: dh,dl,cl

assume cs:code
data segment
    db 'Welcome to masm!',0
data ends

code segment
start:  mov dh,8
        mov dl,3
        mov cl,2
        mov ax,data
        mov ds,ax
        mov si,0
        call show_str

        mov ax,4c00h
        int 21h

show_str:
        mov ch,0
        mov bp,cx         ;保护cl

        mov ax,0b800h   ;显存空间首地址
        mov es,ax
        mov cl,dh
        mov ch,0
        dec cx
        sub bx,bx       ;先算行

    s:  add bx,00a0h
        loop s

        mov cl,dl
        sub di,di
        dec cx          ;再算列

    s1: add di,2
        loop s1

change: mov cl,[si]
        mov ch,0
        jcxz ok

        mov al,ds:[si]
        mov es:[bx+di],al
        mov ax,bp
        mov byte ptr es:[bx+di+1],al

        inc SI
        ADD DI,2
        jmp short change

    ok: ret


code ends
end start
</code></pre>
<p>看着像一个实验九的延续。</p>
<p><img src="Labs/image-21.png" alt="Alt text" /></p>
<p>上图看起来是第七行？</p>
<p><img src="Labs/image-22.png" alt="Alt text" /></p>
<p>只是显示问题。</p>
<h3 id="存变量"><a class="header" href="#存变量">存变量</a></h3>
<pre><code>assume cs:code
data segment
    db 'Welcome to masm!',0
data ends

code segment
start:  mov dh,8
        mov dl,3
        mov cl,2
        mov ax,data
        mov ds,ax
        mov si,0
        call show_str

        mov ax,4c00h
        int 21h

show_str:
        push cx
        push bx
        push ax
        push bp
        push di
        mov ch,0
        mov bp,cx         ;保护cl

        mov ax,0b800h   ;显存空间首地址
        mov es,ax
        mov cl,dh
        mov ch,0
        dec cx
        sub bx,bx       ;先算行

    s:  add bx,00a0h
        loop s

        mov al,DL
        MOV AH,0
        ADD AX,ax
        SUB AX,2          ;再算列
	MOV DI,ax

change: mov cl,[si]
        mov ch,0
        jcxz ok

        mov al,ds:[si]
        mov es:[bx+di],al
        mov ax,bp
        mov byte ptr es:[bx+di+1],al

        inc SI
        ADD DI,2
        jmp short change

    ok: pop di
        pop bp
        pop ax
        pop bx
        pop cx
        ret

code ends
end start
</code></pre>
<h2 id="解决除法溢出问题"><a class="header" href="#解决除法溢出问题">解决除法溢出问题</a></h2>
<p><img src="Labs/image-23.png" alt="Alt text" />
请仔细阅读提示，要是没提示这题想半天。</p>
<p>这题抄了这个<a href="https://blog.csdn.net/Dr_Cheeze/article/details/127515082">解答</a></p>
<pre><code>assume cs:code,ss:stack
stack segment
    dw 8 dup(0)
stack ends

code segment
start:
    mov sp,10H

    mov ax,4240H    ;被除数的低16位
    mov dx,000FH    ;被除数的高16位
    mov cx,0AH    ;除数
    call divdw    ;调用子程序

divdw:

    push bx    ;bx是额外用到的寄存器，要压入栈

    mov bx,ax    ;bx=L
    mov ax,dx    ;ax=H
    mov dx,0    ;dx=0
    div cx        ;计算H/N，结果的商即int(H/N)保存在ax，余数即rem(H/N)保存在dx

                    ;接下来要计算int(H/N)*65536，思考一下，65536就是0001 0000 H，
                    ;因此计算结果就是，高16位=int(H/N)，低16位为0000H。

    push ax        ;将int(H/N)*65536结果的高16位，即int(H/N)，压入栈
    mov ax,0
    push ax        ;将int(H/N)*65536结果的低16位，即0000H，压入栈

                    ;接下来要计算 rem(H/N)*65536 ，同理可得，
                    ;计算结果为 高16位=  rem(H/N)*65536 ，即此时dx的值，
                    ;低16位为 0000H。

    mov ax,bx    ;ax = bx = L ，即 [rem(H/N)*65536 + L]的低16位
    div cx        ;计算 [rem( H/N) * 65536 + L]/N ，结果的商保存在ax，余数保存在dx

                    ;接下来要将两项求和。  左边项的高、低16位都在栈中，
                    ;其中高16位就是最终结果的高16位，低16位是0000H。
                    ;右边项的商为16位，在ax中，也就是最终结果的低16位，
                    ;余数在dx中，也就是最终结果的余数。

    mov cx,dx    ;cx = 最终结果的余数
    pop bx        ;cx = int(H/N)*65536结果的低16位，即0000H。
    pop dx        ;bx = int(H/N)*65536结果的高16位，即最终结果的高16位

    pop bx    ;还原bx的值

    mov ax,4c00H
    int 21H
code ends
end start
</code></pre>
<h2 id="数值显示"><a class="header" href="#数值显示">数值显示</a></h2>
<h3 id="问题版本"><a class="header" href="#问题版本">问题版本</a></h3>
<pre><code>assume cs:code,ds:data,ss:stack
data segment
    db 10 dup(0)
data ends

stack segment
    dw 16 dup(0)    ;32字节
stack ends

code segment
start:

    mov ax,12666    ;要显示的数据
    MOV BX,DATA
    MOV DS,BX
    mov si,0    ;ds:si指向字符串首地址
    call dtoc    ;将数据转为十进制字符

    mov dh,8    ;在屏幕第几行开始显示
    mov dl,3    ;在屏幕第几列开始显示
    mov cl,2    ;显示的字符的颜色
    call show_str

    mov ax,4c00H    ;程序返回
    int 21H


dtoc:    ;功能：将给定的word型数据转为十进制字符形式，存入data段，首地址ds:si
            ;参数：ax 指定的word数据
            ;返回：ds:si指向data段字符串首地址
        PUSH AX
        PUSH BX
        PUSH CX

        MOV BL,0AH
        MOV BH,0
        MOV CH,0

PUSHREMAINDER:
        DIV BL
        MOV CL,AL
        JCXZ POPREMAINDER
        PUSH AX
        INC BH
        JMP SHORT PUSHREMAINDER

POPREMAINDER:
        MOV CL,BH

    S1: POP AX
        ADD AH,30H
        MOV DS:[SI],AH
        LOOP S1

        POP CX
        POP BX
        POP AX
        RET

show_str:
        push cx
        push bx
        push ax
        push bp
        push di
        mov ch,0
        mov bp,cx         ;保护cl

        mov ax,0b800h   ;显存空间首地址
        mov es,ax
        mov cl,dh
        mov ch,0
        dec cx
        sub bx,bx       ;先算行

    s:  add bx,00a0h
        loop s

        mov al,DL
        MOV AH,0
        ADD AX,ax
        SUB AX,2          ;再算列
	MOV DI,ax

change: mov cl,[si]
        mov ch,0
        jcxz ok

        mov al,ds:[si]
        mov es:[bx+di],al
        mov ax,bp
        mov byte ptr es:[bx+di+1],al

        inc SI
        ADD DI,2
        jmp short change

    ok: pop di
        pop bp
        pop ax
        pop bx
        pop cx
        ret
code ends
end start
</code></pre>
<p><img src="Labs/image-25.png" alt="Alt text" /></p>
<p>这里可以看出要用到上一题的除法</p>
<h3 id="正确答案"><a class="header" href="#正确答案">正确答案</a></h3>
<p>这里第二题的答案我用了上一题别人写的程序，他那个写的很好，我不动了。</p>
<pre><code>assume cs:code,ds:data,ss:stack
data segment
    db 10 dup(0)
data ends

stack segment
    dw 16 dup(0)    ;32字节
stack ends

code segment
start:

    mov ax,12666    ;要显示的数据
    MOV BX,DATA
    MOV DS,BX
    mov si,0    ;ds:si指向字符串首地址
    call dtoc    ;将数据转为十进制字符

    mov dh,8    ;在屏幕第几行开始显示
    mov dl,3    ;在屏幕第几列开始显示
    mov cl,2    ;显示的字符的颜色
    call show_str

    mov ax,4c00H    ;程序返回
    int 21H


dtoc:    ;功能：将给定的word型数据转为十进制字符形式，存入data段，首地址ds:si
            ;参数：ax 指定的word数据
            ;返回：ds:si指向data段字符串首地址
        PUSH AX
        PUSH BX
        PUSH CX
        PUSH DX
        PUSH SI
        SUB BX,BX

PUSHREMAINDER:
        MOV CX,0AH
        MOV DX,0
        CALL DIVDW

        ADD AX,DX
        MOV DX,CX
        MOV CX,AX
        PUSH DX
        INC BX
        JCXZ POPREMAINDER
        JMP SHORT PUSHREMAINDER

POPREMAINDER:
        MOV CX,BX

    S1: POP AX
        ADD AL,30H
        MOV DS:[SI],AL
        INC SI
        LOOP S1
	    POP SI
        POP DX
        POP CX
        POP BX
        POP AX
        RET
divdw:

    push bx    ;bx是额外用到的寄存器，要压入栈

    mov bx,ax    ;bx=L
    mov ax,dx    ;ax=H
    mov dx,0    ;dx=0
    div cx        ;计算H/N，结果的商即int(H/N)保存在ax，余数即rem(H/N)保存在dx

                    ;接下来要计算int(H/N)*65536，思考一下，65536就是0001 0000 H，
                    ;因此计算结果就是，高16位=int(H/N)，低16位为0000H。

    push ax        ;将int(H/N)*65536结果的高16位，即int(H/N)，压入栈
    mov ax,0
    push ax        ;将int(H/N)*65536结果的低16位，即0000H，压入栈

                    ;接下来要计算 rem(H/N)*65536 ，同理可得，
                    ;计算结果为 高16位=  rem(H/N)*65536 ，即此时dx的值，
                    ;低16位为 0000H。

    mov ax,bx    ;ax = bx = L ，即 [rem(H/N)*65536 + L]的低16位
    div cx        ;计算 [rem( H/N) * 65536 + L]/N ，结果的商保存在ax，余数保存在dx

                    ;接下来要将两项求和。  左边项的高、低16位都在栈中，
                    ;其中高16位就是最终结果的高16位，低16位是0000H。
                    ;右边项的商为16位，在ax中，也就是最终结果的低16位，
                    ;余数在dx中，也就是最终结果的余数。

    mov cx,dx    ;cx = 最终结果的余数
    pop bx        ;cx = int(H/N)*65536结果的低16位，即0000H。
    pop dx        ;bx = int(H/N)*65536结果的高16位，即最终结果的高16位

    pop bx    ;还原bx的值
    ret

show_str:
        push cx
        push bx
        push ax
        push bp
        push di
        mov ch,0
        mov bp,cx         ;保护cl

        mov ax,0b800h   ;显存空间首地址
        mov es,ax
        mov cl,dh
        mov ch,0
        dec cx
        sub bx,bx       ;先算行

    s:  add bx,00a0h
        loop s

        mov al,DL
        MOV AH,0
        ADD AX,ax
        SUB AX,2          ;再算列
	MOV DI,ax

change: mov cl,DS:[si]
        mov ch,0
        jcxz ok

        mov al,ds:[si]
        mov es:[bx+di],al
        mov ax,bp
        mov byte ptr es:[bx+di+1],al

        inc SI
        ADD DI,2
        jmp short change

    ok: pop di
        pop bp
        pop ax
        pop bx
        pop cx
        ret
code ends
end start
</code></pre>
<p><img src="Labs/image-26.png" alt="Alt text" /></p>
<h3 id="网友答案"><a class="header" href="#网友答案">网友答案</a></h3>
<p>和上面的解答抄了同一个</p>
<pre><code>assume cs:code,ds:data,ss:stack
data segment
    db 10 dup(0)
data ends

stack segment
    dw 16 dup(0)    ;32字节
stack ends

code segment
start:
    mov bx,data    ;设置ds段地址
    mov ds,bx
    mov bx,stack    ;设置栈顶
    mov ss,bx
    mov sp,20H

    mov ax,12666    ;要显示的数据
    mov si,0    ;ds:si指向字符串首地址
    call dtoc    ;将数据转为十进制字符

    mov dh,8    ;在屏幕第几行开始显示
    mov dl,3    ;在屏幕第几列开始显示
    mov cl,2    ;显示的字符的颜色
    call show_str

    mov ax,4c00H    ;程序返回
    int 21H


dtoc:    ;功能：将给定的word型数据转为十进制字符形式，存入data段，首地址ds:si
            ;参数：ax 指定的word数据
            ;返回：ds:si指向data段字符串首地址

    push bx;    ;将子程序用到的寄存器压入栈
    push cx;
    push dx;
    push si;

    mov bx,000aH    ;bl = 除数，bh = 一共除了几次
    mov dx,0    ;即将进行除法，dx是高16位，低16位在ax中

    pushyushu:
    mov cx,0
    mov cl,bl    ;cx = 除数
    call divdw    ;调用不会溢出的除法函数，结果的商的高16位，在dx中，
                    ;低16位在ax中，余数在cx中，余数一定&lt;10

    push cx        ;cx=余数，这个余数在显示的时候要倒序显示，因此先压入栈
    inc bh        ;记录将余数压入栈的次数
    mov cx,ax    ;cx = ax = 结果的商的低16位
    add cx,dx    ;dx是结果的商的高16位，ax和dx一定都是非负数
    jcxz popyushu        ;若cx=0，则说明除法计算已经完毕，跳转下一步执行
    jmp short pushyushu

    popyushu:
    mov ch,0
    mov cl,bh    ;ch=0，所以cx = 将余数压入栈的次数，也就是接下来的循环次数
    s1:
    pop ax;        ;从栈中pop出一个余数
    add ax,30H    ;从数字转为对应的数字字符
    mov ds:[si],al    ;用al就够了
    inc si
    loop s1

    pop si    ;子程序结束，将寄存器的值pop出来
    pop dx;
    pop cx;
    pop bx;

    ret

divdw:    ;功能：计算word型被除数与byte型除数的除法
            ;参数：  ax=被除数低16位，dx=被除数高16位，cx = 除数
            ;返回：  ax=商的低16位，dx=商的高16位，cx = 余数

    ;计算公式： X/N = int( H/N ) * 65536 + [rem( H/N) * 65536 + L]/N
    ;其中X为被除数，N为除数，H为被除数的高16位，L为被除数的低16位，
    ;int()表示结果的商，rem()表示结果的余数。

    push bx    ;bx是额外用到的寄存器，要压入栈

    mov bx,ax    ;bx=L
    mov ax,dx    ;ax=H
    mov dx,0    ;dx=0
    div cx        ;计算H/N，结果的商即int(H/N)保存在ax，余数即rem(H/N)保存在dx

                    ;接下来要计算int(H/N)*65536，思考一下，65536就是0001 0000 H，
                    ;因此计算结果就是，高16位=int(H/N)，低16位为0000H。

    push ax        ;将int(H/N)*65536结果的高16位，即int(H/N)，压入栈
    mov ax,0
    push ax        ;将int(H/N)*65536结果的低16位，即0000H，压入栈

                    ;接下来要计算 rem(H/N)*65536 ，同理可得，
                    ;计算结果为 高16位=  rem(H/N)*65536 ，即此时dx的值，
                    ;低16位为 0000H。

    mov ax,bx    ;ax = bx = L ，即 [rem(H/N)*65536 + L]的低16位
    div cx        ;计算 [rem( H/N) * 65536 + L]/N ，结果的商保存在ax，余数保存在dx

                    ;接下来要将两项求和。  左边项的高、低16位都在栈中，
                    ;其中高16位就是最终结果的高16位，低16位是0000H。
                    ;右边项的商为16位，在ax中，也就是最终结果的低16位，
                    ;余数在dx中，也就是最终结果的余数。

    mov cx,dx    ;cx = 最终结果的余数
    pop bx        ;cx = int(H/N)*65536结果的低16位，即0000H。
    pop dx        ;bx = int(H/N)*65536结果的高16位，即最终结果的高16位

    pop bx    ;还原bx的值

    ret


show_str:
                ;功能：将data段中首地址为ds:si的字符，以指定颜色显示在屏幕指定位置
                ;参数：dh 行号， dl 列号 ，cl 颜色
                ;返回：无

    push dx        ;将子程序用到的寄存器压入栈
    push si
    push ax
    push bx

    mov ax,0B800H    ;设置es为显示区段地址
    mov es,ax

    mov ax,00A0H    ;设置首字符显示的地址
    mul dh
    mov dh,0
    add ax,dx
    add ax,dx
    sub ax,2
    mov bx,ax    ;bx是显示区的偏移地址

    mov al,cl    ;用al存储属性字节
    mov ch,0
    mov si,0

    s:                ;循环读取字符并显示
    mov cl,ds:[si]
    jcxz ok            ;若读到0，就退出循环
    mov es:[bx],cl
    inc bx
    mov es:[bx],al
    inc bx
    inc si
    jmp short s

    ok:        ;将寄存器的值pop出来
    pop bx
    pop ax
    pop si
    pop dx

    ret    ;返回


code ends
end start
</code></pre>
<p>注意他这个里面，对列的计算应该减2.</p>
<p><img src="Labs/image-24.png" alt="Alt text" /></p>
<p>正确结果如上图所示。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project1"><a class="header" href="#project1">Project1</a></h1>
<p>首先我们看一下lab7的结果！</p>
<p><img src="Labs/image-31.png" alt="Alt text" /></p>
<p>其实我们可以看到，lab7的结果已经存在table段之中了。后面要做什么？把收入和雇员还有平均收入，搞成十进制的！然后，这些东西一起展示在屏幕上！</p>
<h2 id="dtoc"><a class="header" href="#dtoc">dtoc</a></h2>
<pre><code>assume cs:code,ds:data,ss:stack
data segment
    db 10 dup(0)
data ends

stack segment
    dw 16 dup(0)    ;32字节
stack ends

code segment
start:
    mov dx,1
    mov ax,12666    ;要显示的数据
    MOV BX,DATA
    MOV DS,BX
    mov si,0    ;ds:si指向字符串首地址
    call dtoc    ;将数据转为十进制字符

    mov dh,8    ;在屏幕第几行开始显示
    mov dl,3    ;在屏幕第几列开始显示
    mov cl,2    ;显示的字符的颜色
    call show_str

    mov ax,4c00H    ;程序返回
    int 21H


dtoc:    ;功能：将给定的word型数据转为十进制字符形式，存入data段，首地址ds:si
            ;参数：ax 指定的word数据
            ;返回：ds:si指向data段字符串首地址
        PUSH AX
        PUSH BX
        PUSH CX
        PUSH DX
        PUSH SI
        SUB BX,BX

PUSHREMAINDER:
        MOV CX,0AH
        CALL DIVDW

        PUSH CX
        MOV CX,DX
        ADD CX,AX
        INC BL
        JCXZ POPREMAINDER
        JMP SHORT PUSHREMAINDER

POPREMAINDER:
        MOV CX,BX

    S1: POP AX
        ADD AL,30H
        MOV DS:[SI],AL
        INC SI
        LOOP S1
	POP SI
        POP DX
        POP CX
        POP BX
        POP AX
        RET
divdw:
	PUSH bx
        push ax             ;将被除数低16位先压栈保存。
        mov ax, dx          ;（ax）=（dx）
        mov dx, 0000H       ;
        div cx              ;被除数dx+ax（组合），除数cx。
        mov bx, ax          ;将H/N结果的商先保存在bx中，（bx）=0001H
        pop ax              ;将L值弹栈到ax
        div cx
        mov cx, dx          ;返回值（cx）等于最终结果的余数
        mov dx, bx          ;最终结果高16位值=（bx）
        POP bx
        ret

show_str:
        push cx
        push bx
        push ax
        push bp
        push di
        mov ch,0
        mov bp,cx         ;保护cl

        mov ax,0b800h   ;显存空间首地址
        mov es,ax
        mov cl,dh
        mov ch,0
        dec cx
        sub bx,bx       ;先算行

    s:  add bx,00a0h
        loop s

        mov al,DL
        MOV AH,0
        ADD AX,ax
        SUB AX,2          ;再算列
	MOV DI,ax

change: mov cl,DS:[si]
        mov ch,0
        jcxz ok

        mov al,ds:[si]
        mov es:[bx+di],al
        mov ax,bp
        mov byte ptr es:[bx+di+1],al

        inc SI
        ADD DI,2
        jmp short change

    ok: pop di
        pop bp
        pop ax
        pop bx
        pop cx
        ret
code ends
end start
</code></pre>
<p><img src="Labs/image-32.png" alt="Alt text" /></p>
<p>是这么个结果</p>
<p><img src="Labs/image-33.png" alt="Alt text" /></p>
<p>可见改的没毛病。</p>
<h2 id="答案"><a class="header" href="#答案">答案</a></h2>
<p><img src="Labs/image-34.png" alt="Alt text" />
惨痛，用了个缓冲区，忘了清空了,注意那个854，那是错误答案。</p>
<pre><code>assume cs:code,ss:stack
data segment
    db '                       ',0
data ends

stack segment
    dw 16 dup(0)    ;32字节
stack ends

datasg segment
    db '1975', '1976', '1977', '1978', '1979', '1980', '1981'
    db '1982', '1983', '1984', '1985', '1986', '1987', '1988'
    db '1989', '1990', '1991', '1992', '1993', '1994', '1995'

    dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479
    dd 140417, 197514, 345980, 590827, 803530, 1183000, 1843000
    dd 2759000, 3753000, 4649000, 5937000

    dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778, 1001, 1442, 2258
    dw 2793, 4037, 5635, 8226, 11542, 14430, 15257, 17800
datasg ends

table segment
    db 21 dup ('year summ ne ?? ')
table ends

code segment

start:
        mov ax,datasg
        mov es,ax               ;data绑es

        mov ax,table
        mov ds,ax               ;table绑ds,这样寻址的时候不用写段地址

        sub bx,bx
        sub si,si
        mov di,168              ;这个必须自己算一下，4*21+4*21
                                ;这里本来想全用si，但是问题在于si加的话，一个收入是DWORD，一个人数是WORD，直接加会导致跳过一个人数，等于你1976对应的人是1977的，1977对应的人是1979的。没办法只能用新的寄存器存了

        mov cx,21
    s:  mov ax,es:[si]
        mov [bx].0h[0],ax
        mov ax,es:[si+2]
        mov [bx].0h[2],ax       ;存年份，四个byte，存两次即可

        mov ax,es:[di]
        mov [bx].10[0],ax       ;人数是字，直接存

        mov ax,es:[si+84]
        mov [bx].5[0],ax
        mov dx,es:[si+86]
        mov [bx].5[2],dx        ;收入是双字，要存两次，然后为了和后面的除法对应上，直接存dx和ax里,这里要注意小端存储
                                ;这里可以看到，一个年份和对应的收入，其实大小都是4字节的。这样si可以一次循环内使用。

        div word ptr es:[di]    ;指明除数的长度
        mov [bx].13[0],ax

        add bx,10h
        add si,4
        add di,2
        loop s

        ;底下就是新的内容了
        mov ax,data
        mov ds,ax
        ;ds绑定table
        mov ax,table
        mov es,ax
        ;es绑table

        mov cx,21
        SUB BX,BX;计数器
        sub si,si
        sub di,di
    convert:
        sub si,si
        push cx

        mov cx,4
    year:
        ;挪年份进去
        mov al,es:[di]
        mov ds:[si],al
        inc si
        inc di
        loop year

        inc di
        inc si

        ;总收入
        mov dx,es:[di+2]
        mov ax,es:[di]
        call dtoc

        add di,5
        add si,8
        mov dx,0
        mov ax,es:[di]
        call dtoc
        ;人

        add di,3
        add si,7
        mov dx,0
        mov ax,es:[di]
        call dtoc
        ;人均

        ;其实上边这几个部分，精心设计一下能写成循环，代码能好看一点点，但是太麻烦了，不写了。


        mov si,0    ;ds:si指向字符串首地址

        mov dh,BL    ;在屏幕第几行开始显示
        mov dl,3    ;在屏幕第几列开始显示
        mov cl,2    ;显示的字符的颜色
        call show_str

        ;这里还要注意，每次展示以后都要重新清空
        mov cx,24
        SUB SI,si
    clearbuf:
        mov BYTE ptr ds:[si],20h
        INC si
        loop clearbuf

        sub di,13
        add di,10H
        inc bl
        pop cx
        loop convert



    mov ax,4c00H    ;程序返回
    int 21H


dtoc:    ;功能：将给定的word型数据转为十进制字符形式，存入data段，首地址ds:si
            ;参数：ax 指定的word数据
            ;返回：ds:si指向data段字符串首地址
        PUSH AX
        PUSH BX
        PUSH CX
        PUSH DX
        PUSH SI
        SUB BX,BX

PUSHREMAINDER:
        MOV CX,0AH
        CALL DIVDW

        PUSH CX
        MOV CX,DX
        ADD CX,AX
        INC BL
        JCXZ POPREMAINDER
        JMP SHORT PUSHREMAINDER

POPREMAINDER:
        MOV CX,BX

    S1: POP AX
        ADD AL,30H
        MOV DS:[SI],AL
        INC SI
        LOOP S1
	POP SI
        POP DX
        POP CX
        POP BX
        POP AX
        RET
divdw:
	PUSH bx
        push ax             ;将被除数低16位先压栈保存。
        mov ax, dx          ;（ax）=（dx）
        mov dx, 0000H       ;
        div cx              ;被除数dx+ax（组合），除数cx。
        mov bx, ax          ;将H/N结果的商先保存在bx中，（bx）=0001H
        pop ax              ;将L值弹栈到ax
        div cx
        mov cx, dx          ;返回值（cx）等于最终结果的余数
        mov dx, bx          ;最终结果高16位值=（bx）
        POP bx
        ret

show_str:
        push cx
        push bx
        push ax
        push bp
        push di
        push es
        mov ch,0
        mov bp,cx         ;保护cl

        mov ax,0b800h   ;显存空间首地址
        mov es,ax
        mov cl,dh
        mov ch,0
        sub bx,bx       ;先算行

    s2:  add bx,00a0h
        loop s2

        mov al,DL
        MOV AH,0
        ADD AX,ax
        SUB AX,2          ;再算列
	MOV DI,ax

change: mov cl,DS:[si]
        mov ch,0
        jcxz ok

        mov al,ds:[si]
        mov es:[bx+di],al
        mov ax,bp
        mov byte ptr es:[bx+di+1],al

        inc SI
        ADD DI,2
        jmp short change

    ok: pop es
        pop di
        pop bp
        pop ax
        pop bx
        pop cx
        ret
code ends
end start
</code></pre>
<p><img src="Labs/image-39.png" alt="Alt text" /></p>
<p>成功！</p>
<p>有点儿难度，自己在写之前要想清楚，不然调起来很费劲。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实验十一"><a class="header" href="#实验十一">实验十一</a></h1>
<p>把字符串里所有的小写字母转为大写字母。</p>
<pre><code>assume cs:code

datasg segment
    db &quot;Beginner's ALL-purpose Symbolic Instruction Code.&quot;,0
datasg ends

code segment
begin:  mov ax,datasg
        mov ds,ax
        mov si,0
        call letterc

        mov ax,4c00h
        int 21h

letterc:
        push cx

    start:
        mov cl,ds:[si]
        jcxz finish
        cmp cl,61H
        jb ok
        cmp cl,7Ah
        ja ok
        and cl,0DFH
        mov ds:[si],cl

    ok: inc si
        jmp short start
    finish:
        pop cx
        ret

code ends
end begin
</code></pre>
<p><img src="Labs/image-27.png" alt="Alt text" /></p>
<p><img src="Labs/image-28.png" alt="Alt text" /></p>
<p>好水的实验</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实验十二"><a class="header" href="#实验十二">实验十二</a></h1>
<ol>
<li>do0程序放在哪？放在0000:2000-0000:02FF之中</li>
<li>do0的入口地址，放在中断向量表0号表项</li>
<li>如何获取代码长度？编译器来做！利用offset计算</li>
<li>overflow!应该在哪？在cs之中！</li>
</ol>
<pre><code>assume cs:code

code segment
start:  mov ax,cs
        mov ds,ax
        mov si,offset do0
        mov ax,0
        mov es,ax
        mov di,200h
        mov cx,offset do0end-offset do0
        cld
        rep movsb
        ;上面的步骤把整个do0复制到了0000:0200开始的内存空间之中

        mov ax,0
        mov es,ax

        mov word ptr es:[0*4],200h
        mov word ptr es:[0*4+2],0
        ;这几行把0号中断的中断处理程序的入口点设置为了0000:0200

        ;接下来试验一下
        mov ax,1000
        mov bh,01
        div bh

        mov ax,4c00h
        int 21h

    do0:
        jmp short do0start
        db &quot;divide error!&quot;
    do0start:
        mov ax,cs
        mov ds,ax
        mov si,202h

        mov ax,0b800h
        mov es,ax
        mov di,12*160+36*2

        mov cx,13
    s:  mov al,[si]
        mov es:[di],al
        inc si
        add di,2
        loop s

        mov ax,4c00h
        int 21h
    do0end:
        nop

code ends
end start
</code></pre>
<p><img src="Labs/image-29.png" alt="Alt text" />
<img src="Labs/image-30.png" alt="Alt text" /></p>
<p>实验成功！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编写应用中断程序"><a class="header" href="#编写应用中断程序">编写、应用中断程序</a></h1>
<h2 id="编写并安装int-17h中断程序"><a class="header" href="#编写并安装int-17h中断程序">编写并安装int 17h中断程序</a></h2>
<p>又是缝合性实验</p>
<pre><code>assume cs:code

code segment
start:  mov ax,cs
        mov ds,ax
        mov si,offset show_str
        mov ax,0
        mov es,ax
        mov di,200h
        mov cx,offset show_str_end-offset show_str
        cld
        rep movsb
        ;上面的步骤把整个do0复制到了0000:0200开始的内存空间之中

        mov ax,0
        mov es,ax

        mov word ptr es:[7ch*4],200h
        mov word ptr es:[7ch*4+2],0
        ;这几行把0号中断的中断处理程序的入口点设置为了0000:0200
        mov ax,4c00h
        int 21h

show_str:
        mov ch,0
        mov bp,cx         ;保护cl

        mov ax,0b800h   ;显存空间首地址
        mov es,ax
        mov cl,dh
        mov ch,0
        dec cx
        sub bx,bx       ;先算行

    s:  add bx,00a0h
        loop s

        mov cl,dl
        sub di,di
        dec cx          ;再算列

    s1: add di,2
        loop s1

change: mov cl,[si]
        mov ch,0
        jcxz ok

        mov al,ds:[si]
        mov es:[bx+di],al
        mov ax,bp
        mov byte ptr es:[bx+di+1],al

        inc SI
        ADD DI,2
        jmp short change

    ok: iret
show_str_end:nop
code ends
end start
</code></pre>
<p>很简单的东东hhh</p>
<pre><code>assume cs:code
data segment
    db 'Welcome to Masm!',0
data ends
code segment
start:
    mov dh,10
    mov dl,10
    mov cl,2
    mov ax,data
    mov ds,ax
    mov si,0
    int 7ch
    mov ax,4c00h
    int 21h
code ends
end start
</code></pre>
<p><img src="Labs/image-36.png" alt="Alt text" /></p>
<p>可以看到成功！</p>
<h2 id="7ch的中断程序模拟循环"><a class="header" href="#7ch的中断程序模拟循环">7ch的中断程序模拟循环</a></h2>
<pre><code>assume cs:code
code segment
start:
	mov ax,0b800h
	mov es,ax
	mov di,160*12
	mov bx,offset s-offset se 				;设置从标号se到标号s的转移位移
	mov cx,80
s:
	mov byte ptr es:[di],'!'
	add di,2
	int 7ch									;如果(cx)≠0，转移到标号s处
se:
	nop
	mov ax,4c00h
	int 21h
code ends
end start
</code></pre>
<p>而中断程序，书里几乎都给出了</p>
<pre><code>assume cs:code
code segment

start:
	mov ax,cs
	mov ds,ax
	mov si,offset lp
	mov ax,0
	mov es,ax
	mov di,200h
	mov cx,offset lpred-offset lp
	cld
	rep movsb

	;设置中断向量表
	mov ax,0
	mov es,ax
	mov word ptr es:[7ch*4],200h
	mov word ptr es:[7ch*4+2],0

	mov ax,4c00h
	int 21h

lp:
	push bp
	mov bp,sp
	dec cx
	jcxz lpret
	add [bp+2],bx
lpret:
	pop bp
	iret
lpred:
	nop

code ends
end start
</code></pre>
<p><img src="Labs/image-37.png" alt="Alt text" /></p>
<h2 id="填空"><a class="header" href="#填空">填空</a></h2>
<p>看一下10号中断是咋回事儿即可</p>
<ol>
<li>ds:[si]</li>
<li>ds:[bx]</li>
<li>inc si</li>
<li>add bx,2</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="访问cmos-ram"><a class="header" href="#访问cmos-ram">访问CMOS RAM</a></h1>
<pre><code>assume cs:code

data segment
    db 'yy/mm/ss hh:mm:ss', 0   ;输出模板
data ends
code segment
 start:
        mov ax, data
        mov ds, ax
        mov si, 0               ;初始化输出模板

        mov bx, 9               ;方便循环操作
        mov dx, 3               ;计数
        mov cl, 4

    y_m_s:
        mov al, bl
        out 70h, al             ;给70h端口送入9,访问CMOS-9号地址
        in al, 71h              ;拿出9号地址中间的内容
        mov ah, al
        call handle

        dec bx
        dec dx

        cmp dx, 0               ;判断循环是否结束
        je h_m_s_start

        jmp short y_m_s

    h_m_s_start:
        mov bx, 4
        mov dx, 3

    h_m_s:
        mov al, bl
        out 70h, al
        in al, 71h
        mov ah, al

        call handle
        sub bx, 2
        dec dx

        cmp dx, 0
        je print_str_start
        jmp short h_m_s

        print_str_start:
        mov dh,12
        mov dl,38
        mov cl,2
        mov ax,data
        mov ds,ax
        mov si,0
        call show_str

        mov ax, 4c00h
        int 21h

handle:
        shr ah, cl              ;只需要前面4个字节
        and al, 00001111b       ;只需要后面4个字节

        add ah, 30h
        add al, 30h

        mov [si], ah            ;放入模板字符串中
        mov [si+1], al
        add si, 3
        ret
show_str:
        mov ch,0
        mov bp,cx         ;保护cl

        mov ax,0b800h   ;显存空间首地址
        mov es,ax
        mov cl,dh
        mov ch,0
        dec cx
        sub bx,bx       ;先算行

    s:  add bx,00a0h
        loop s

        mov cl,dl
        sub di,di
        dec cx          ;再算列

    s1: add di,2
        loop s1

change: mov cl,[si]
        mov ch,0
        jcxz ok

        mov al,ds:[si]
        mov es:[bx+di],al
        mov ax,bp
        mov byte ptr es:[bx+di+1],al

        inc SI
        ADD DI,2
        jmp short change

    ok: ret

code ends
end start
</code></pre>
<p><img src="Labs/image-35.png" alt="Alt text" /></p>
<p>改了一下网友的答案，没啥兴趣写了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="按下a后除非不松开否则满屏a"><a class="header" href="#按下a后除非不松开否则满屏a">按下A后除非不松开，否则满屏A</a></h1>
<pre><code>assume cs:code
stack segment
  db 128 dup (0)
stack ends

code segment
start:
	mov ax,stack
	mov ss,ax
	mov sp,128

	push cs
	pop ds

	mov ax,0
	mov es,ax

	mov si,offset int9
	mov di,204h
	mov cx,offset int9ends-offset int9
	cld
	rep movsb

	cli
	push es:[9*4]
	pop es:[200h]
	push es:[9*4+2]
	pop es:[202h]

	mov word ptr es:[9*4],204h
	mov word ptr es:[9*4+2],0
	sti

	mov ax,4c00h
	int 21h

int9:
	push ax
	push bx
	push cx
	push es

	in al,60h

	pushf
	call dword ptr cs:[200h]

	cmp al,9eh		;A的通码1EH,+80h
	jne int9ret

	mov ax,0b800h
	mov es,ax
	mov bx,0
	mov cx,2000
s:
	mov byte ptr es:[bx],'A'
	add bx,2
	loop s

int9ret:
	pop es
	pop cx
	pop bx
	pop ax
	iret

int9ends:	nop

code ends
end start

</code></pre>
<p><img src="Labs/image-38.png" alt="Alt text" /></p>
<p>水水罢了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="也挺水的"><a class="header" href="#也挺水的">也挺水的</a></h1>
<pre><code>assume cs:code
code segment
start:
	mov ax,cs
	mov ds,ax
	mov si,offset setscreen
	mov ax,0
	mov es,ax
	mov di,200h
	cld
	mov cx,offset setscreenends - offset setscreen
	rep movsb

	cli
	mov word ptr es:[7ch*4],200h
	mov word ptr es:[7ch*4+2],0
	sti

	mov ax,4c00h
	int 21h


setscreen:
    cmp ah,0
    je do1
    cmp ah,1
    je do2
    cmp ah,2
    je do3
    cmp ah,3
    je do4
    jmp short sret

do1:    call sub1
        jmp short sret
do2:    call sub2
        jmp short sret
do3:    call sub3
        jmp short sret
do4:    call sub4

sret:   ret
sub1:					;1号子程序
	push bx
	push cx
	push es
	mov bx,0b800h
	mov es,bx
	mov bx,0
	mov cx,2000
  sub1s:
	mov byte ptr es:[bx],' '
	add bx,2
	loop sub1s
	pop es
	pop cx
	pop bx
	ret

sub2:					;2号子程序
	push bx
	push cx
	push es
	mov bx,0b800h
	mov es,bx
	mov bx,1
	mov cx,2000
        sub2s:
	and byte ptr es:[bx],11111000b
	or es:[bx],al
	add bx,2
	loop sub2s
	pop es
	pop cx
	pop bx
	ret

sub3:					;3号子程序
	push bx
	push cx
	push es
	mov cl,4
	shl al,cl
	mov bx,0b800h
	mov es,bx
	mov bx,1
	mov cx,2000
        sub3s:
	and byte ptr es:[bx],10001111b
	or es:[bx],al
	add bx,2
	loop sub3s
	pop es
	pop cx
	pop bx
	ret

sub4:					;4号子程序
	push cx
	push si
	push di
	push es
	push ds

	mov si,0b800h
	mov es,si
	mov ds,si
	mov si,160
	mov di,0
	cld
	mov cx,24
        sub4s:
	push cx
	mov cx,160
	rep movsb
	pop cx
	loop sub4s

	mov cx,80
	mov si,0
        sub4s1:
	mov byte ptr [160*24+si],' '
	add si,2
	loop sub4s1

	pop ds
	pop es
	pop di
	pop si
	pop cx
	ret
setscreenends:
	nop

code ends
end start

</code></pre>
<p>也是水水罢了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="程序"><a class="header" href="#程序">程序</a></h1>
<p>需要按步骤来</p>
<h2 id="dashboard"><a class="header" href="#dashboard">dashboard</a></h2>
<pre><code>assume cs:code

dashboard segment
    db '  Welcome      '
    db '               '
    db '1)reset pc     '
    db '2)start system '
    db '3)clock        '
    db '4)set clock    '
    db '               '
    db 'TephrocactusMYC'
dashboard ends

code segment

start:
    call showdashboard

    mov ax,4c00h
    int 21h


;这里是展示界面
showdashboard:
    push cx
    push ax
    push si
    push di
    mov ax,0b800h
    mov es,ax
    sub si,si
    mov di,8*160+30*2

    mov ax,dashboard
    mov ds,ax

    mov cx,8
loopdash:
    push cx

    mov cx,15
loopdash1:
    mov al,ds:[si]
    mov es:[di],al
    inc si
    add di,2
    loop loopdash1
    add di,130
    pop cx
    loop loopdash

    pop di
    pop si
    pop ax
    pop cx
    ret

code ends
end start
</code></pre>
<p><img src="Labs/image-40.png" alt="Alt text" /></p>
<p>可见dashboard展示成功！</p>
<p>这里我自己做了美化.</p>
<p>然后也改为int 16h中断调用</p>
<pre><code>assume cs:code

dashboard segment
    db '  Welcome      '
    db '               '
    db '1)reset pc     '
    db '2)start system '
    db '3)clock        '
    db '4)set clock    '
    db '               '
    db 'TephrocactusMYC'
dashboard ends

code segment

start:
    MOV AH,0
    INT 16H
    CMP AH,1
    JE showdashboard


    mov ax,4c00h
    int 21h

;这里是展示界面
showdashboard:
    push cx
    push ax
    push si
    push di
    mov ax,0b800h
    mov es,ax
    sub si,si
    mov di,8*160+30*2

    mov ax,dashboard
    mov ds,ax

    mov cx,8
loopdash:
    push cx

    mov cx,15
loopdash1:
    mov al,ds:[si]
    mov es:[di],al
    inc si
    add di,2
    loop loopdash1
    add di,130
    pop cx
    loop loopdash

    pop di
    pop si
    pop ax
    pop cx
    ret

code ends
end start
</code></pre>
<h2 id="按fi改变颜色"><a class="header" href="#按fi改变颜色">按FI改变颜色</a></h2>
<p>这个书里给了</p>
<pre><code>assume cs:code
stack segment
    db 128 dup(0)
stack ends
code segment
start:
    mov ax,stack
    mov ss,ax
    mov sp,128

    push cs
    pop ds

    mov ax,0
    mov es,ax

    mov si,offset int9
    mov di,204h
    mov cx,offset int9end-offset int9
    cld
    rep movsb

    push es:[9*4]
    pop es:[200h]
    push es:[9*4+2]
    pop es:[202h]

    cli
    mov word ptr es:[9*4],204h
    mov word ptr es:[9*4+2],0
    sti

    mov ax,4c00h
    int 21h

int9:
    push ax
    push bx
    push cx
    push es

    in al,60h
    pushf
    call dword ptr cs:[200h]

    cmp al,3bh
    je changecolor
    jne int9ret

changecolor:
    mov ax,0b800h
    mov es,ax
    mov bx,1
    mov cx,2000
loopint9:
    inc byte ptr es:[bx]
    add bx,2
    loop loopint9

int9ret:
    pop es
    pop cx
    pop bx
    pop ax
    iret

int9end:nop
code ends
end start
</code></pre>
<p>改写一下变成安装的程序。</p>
<pre><code>assume cs:code
stack segment
    db 128 dup(0)
stack ends
code segment
start:
    mov ax,stack
    mov ss,ax
    mov sp,128

    push cs
    pop ds

    mov ax,0
    mov es,ax

    call install_int9

    mov ax,4c00h
    int 21h


install_int9:
    mov si,offset int9_start
    mov di,204h
    mov cx,offset int9_end-offset int9_start
    cld
    rep movsb

    push es:[9*4]
    pop es:[200h]
    push es:[9*4+2]
    pop es:[202h]

    cli
    mov word ptr es:[9*4],204h
    mov word ptr es:[9*4+2],0
    sti
    ret


int9_start:
    push ax
    push bx
    push cx
    push es

    in al,60h
    pushf
    call dword ptr cs:[200h]

    cmp al,3bh
    je changecolor
    jne int9ret

changecolor:
    mov ax,0b800h
    mov es,ax
    mov bx,1
    mov cx,2000
loopint9:
    inc byte ptr es:[bx]
    add bx,2
    loop loopint9

int9ret:
    pop es
    pop cx
    pop bx
    pop ax
    iret

int9_end:nop
code ends
end start
</code></pre>
<p>可以实现功能</p>
<h2 id="展示时间"><a class="header" href="#展示时间">展示时间</a></h2>
<p>前面写(抄+改)过一个，那个看起来不太星，自己写了。。。</p>
<p>改两件事：</p>
<ul>
<li>一是正常的输出，之前写的还有颜色啥的，这里都不需要了。</li>
<li>二是重头戏，循环，也就是说每秒展示的都是当前的状态，这个怎么办呢，弄个循环，每次循环结束之前inc cx即可</li>
</ul>
<p><em>ps:这个设计感觉有些问题，因为CPU执行的速度太快了，每秒可能执行了上万次，这样虽然是每秒展示实时时间，但其实每一秒展示了上万次了</em></p>
<pre><code>assume cs:code

timeshow segment
    db 'yy/mm/ss hh:mm:ss',0   ;输出模板
timeshow ends

code segment
    cmos db 9,8,7,4,2,0
 start:
        call showtime
        mov cx,4c00h
        int 21h

showtime:
        mov ax,timeshow
        mov ds,AX
        mov ax,0b800h   ;显存空间首地址
        mov es,ax
        call print_time

readtime:
        mov cx,6
        sub si,si
        mov di,12*160+26*2
SIXTIME:
        mov al,cmos[si]
        out 70h,al
        in al,71h

        mov ah,al
        shr ah,1
        shr ah,1
        shr ah,1
        shr ah,1
        and al,00001111b
        add ah,30h
        add al,30h

        mov es:[di],ah
        mov es:[DI+2],al

        inc si
        add di,6
        loop SIXTIME
        JMP readtime

        ret

print_time:
        push ax
        push ES
        push bx
        push cx
        push si
        push DI
	SUB DI,DI
        sub si,si
        mov ax,0b800h   ;显存空间首地址
        mov es,ax
        mov bx,12*160+26*2

change: mov cl,ds:[si]
        mov ch,0
        jcxz ok

        mov al,ds:[si]
        mov es:[bx+di],al
        inc SI
        ADD DI,2
        jmp short change

    ok: pop di
        pop si
        pop cx
        pop bx
        pop es
        pop ax
        RET

code ends
end start
</code></pre>
<h2 id="组合"><a class="header" href="#组合">组合</a></h2>
<p>接下来把显示时钟和展示封面，还有互相之间的切换，组合起来。</p>
<p>这里要做的不少，一是处理按<code>ESC</code>之后切换，而是按<code>3</code>之后切换到时钟这里，这里需要注意清屏。</p>
<h3 id="清屏"><a class="header" href="#清屏">清屏</a></h3>
<p>首先我们来看一下这个清屏的子过程</p>
<pre><code>;清屏的
;================================================
clearscreen:
    push bx
    push cx
    push es
    mov bx,0b800h
    mov es,bx
    mov bx,0
    mov cx,2000
subclear:
    mov byte ptr es:[bx],' '
    add bx,2
    loop subclear

    pop es
    pop cx
    pop bx
    ret
;================================================
</code></pre>
<h3 id="组合-1"><a class="header" href="#组合-1">组合</a></h3>
<p>然后组合</p>
<pre><code>assume cs:code,ss:stack
timeshow segment
    db 'yy/mm/ss hh:mm:ss',0   ;输出模板
timeshow ends

data segment
	db	128 dup (0)
data ends

stack segment stack
	db	128 dup (0)
stack ends

dashboard segment
    db '  Welcome      '
    db '               '
    db '1)reset pc     '
    db '2)start system '
    db '3)clock        '
    db '4)set clock    '
    db '               '
    db 'TephrocactusMYC'
dashboard ends

code segment

	start:	mov ax,stack
		mov ss,ax
		mov sp,128
		call cpy_boot
		call sav_old_int9

		mov bx,0
		push bx
		mov bx,7E00H
		push bx
		retf

		mov ax,4C00H
		int 21H


;========================================================
Boot:		jmp BOOT_START
cmos db 9,8,7,4,2,0
BOOT_START:	call init_reg
		call clearscreen
		call showdashboard
		jmp choose_option

		mov ax,4C00H
		int 21H

;=======================================================
choose_option:	call clear_buff

		mov ah,0
		int 16H
		cmp al,'1'
		je isChooseOne
		cmp al,'2'
		je isChooseTwo
		cmp al,'3'
		je isChooseThree
		cmp al,'4'
		je isChooseFour

		jmp showdashboard

isChooseOne:	mov di,160*4
		mov byte ptr es:[di],'1'
		jmp choose_option

isChooseTwo:	mov di,160*4
		mov byte ptr es:[di],'2'
		jmp choose_option

isChooseThree:	mov di,160*4
		mov byte ptr es:[di],'3'
		call showtime
		jmp BOOT_START

isChooseFour:	mov di,160*4
		mov byte ptr es:[di],'4'
		jmp choose_option

;这里是展示界面
;=======================================================
showdashboard:
    push cx
    push ax
    push si
    push di
    mov ax,0b800h
    mov es,ax
    sub si,si
    mov di,8*160+30*2

    mov ax,dashboard
    mov ds,ax

    mov cx,8
loopdash:
    push cx

    mov cx,15
loopdash1:
    mov al,ds:[si]
    mov es:[di],al
    inc si
    add di,2
    loop loopdash1
    add di,130
    pop cx
    loop loopdash

    pop di
    pop si
    pop ax
    pop cx
    ret
;=======================================================
showtime:
	call clearscreen
        mov ax,0b800h   ;显存空间首地址
        mov es,ax
        call print_time
        call set_new_int9
        MOV AX,0
        MOV DS,ax

readtime:
        mov cx,6
        mov si,OFFSET CMOS - OFFSET Boot + 7E00H
        mov di,12*160+26*2
SIXTIME:
        mov al,DS:[si]
        out 70h,al
        in al,71h

        mov ah,al
        shr ah,1
        shr ah,1
        shr ah,1
        shr ah,1
        and al,00001111b
        add ah,30h
        add al,30h

        mov es:[di],ah
        mov es:[DI+2],al

        inc si
        add di,6
        loop SIXTIME
        JMP readtime

        ret

print_time:
        push ax
        push bx
        push cx
        push si
        push DI
        PUSH ds
	    SUB DI,DI
        sub si,SI
        mov ax,timeshow
        mov ds,AX
        mov bx,12*160+26*2

change: mov cl,ds:[si]
        mov ch,0
        jcxz ok

        mov al,ds:[si]
        mov es:[bx+di],al
        inc SI
        ADD DI,2
        jmp short change

    ok: POP ds
    	pop di
        pop si
        pop cx
        pop bx
        pop ax
        RET

showDateOver:	call set_old_int9

		ret

;=======================================================
set_old_int9:
		push bx
		push es

		mov bx,0
		mov es,bx

		cli
		push es:[200H]
		pop es:[9*4]
		push es:[202H]
		pop es:[9*4+2]
		sti

		pop es
		pop bx
		ret
;=======================================================
set_new_int9:	push bx
		push es

		mov bx,0
		mov es,bx

		mov word ptr es:[9*4],OFFSET new_int9 - OFFSET Boot + 7E00H
		mov word ptr es:[9*4+2],0

		pop es
		pop bx
		ret
;=======================================================
new_int9:	push ax

		call clear_buff

		in al,60H
		pushf
		call dword ptr cs:[200H]

		cmp al,01H
		je isEsc
		cmp al,3BH
		jne int9Ret
		call changecolor


int9Ret:	pop ax
		iret


isEsc:		pop ax
		add sp,4
		popf
		jmp showDateOver

;=======================================================
changecolor:
    push ax
    push bx
    push cx
    push es
    mov ax,0b800h
    mov es,ax
    mov bx,1
    mov cx,2000
loopint9:
    inc byte ptr es:[bx]
    add bx,2
    loop loopint9

    pop es
    pop cx
    pop bx
    pop ax
    ret
;=======================================================
clear_buff:	mov ah,1
		int 16H
		jz clearBuffRet
		mov ah,0
		int 16H
		jmp clear_buff

clearBuffRet:	ret

;清屏，这里做了修改，为了不让F1的效果一直保留。
;=======================================================
clearscreen:
    push bx
    push cx
    push es
    mov bx,0b800h
    mov es,bx
    mov bx,0
    mov cx,2000
subclear:
    mov byte ptr es:[bx],' '
    add bx,2
    loop subclear

    pop es
    pop cx
    pop bx
    ret
;=======================================================
init_reg:
		mov bx,0B800H
		mov es,bx

		mov bx,0
		mov ds,bx
		ret

Boot_end:	nop

;========================================================
sav_old_int9:	mov bx,0
		mov es,bx

		push es:[9*4]
		pop es:[200H]
		push es:[9*4+2]
		pop es:[202H]

		ret
;========================================================
cpy_boot:
		mov bx,cs
		mov ds,bx
		mov si,OFFSET Boot

		mov bx,0
		mov es,bx
		mov di,7E00H

		mov cx,OFFSET Boot_end - OFFSET Boot
		cld
		rep movsb

		ret

code ends

end start
</code></pre>
<h3 id="加入修改时间"><a class="header" href="#加入修改时间">加入修改时间</a></h3>
<pre><code>assume cs:code,ss:stack
timeshow segment
    db 'yy/mm/ss hh:mm:ss',0   ;输出模板
timeshow ends

data segment
	db	128 dup (0)
data ends

stack segment stack
	db	512 dup (0)
stack ends

dashboard segment
    db '  Welcome      '
    db '               '
    db '1)reset pc     '
    db '2)start system '
    db '3)clock        '
    db '4)set clock    '
    db '               '
    db 'TephrocactusMYC'
dashboard ends

code segment

	start:	mov ax,stack
		mov ss,ax
		mov sp,128
		call cpy_boot
		call sav_old_int9

		mov bx,0
		push bx
		mov bx,7E00H
		push bx
		retf

		mov ax,4C00H
		int 21H


;========================================================
Boot:		jmp BOOT_START
cmos db 9,8,7,4,2,0
STRING_STACK db 'YYMMDDhhmmss',0
BOOT_START:	call init_reg
		call clearscreen
		call showdashboard
		jmp choose_option

		mov ax,4C00H
		int 21H

;=======================================================
choose_option:	call clear_buff

		mov ah,0
		int 16H
		cmp al,'1'
		je isChooseOne
		cmp al,'2'
		je isChooseTwo
		cmp al,'3'
		je isChooseThree
		cmp al,'4'
		je isChooseFour

		jmp showdashboard

isChooseOne:	mov di,160*4
		mov byte ptr es:[di],'1'
		jmp choose_option

isChooseTwo:	mov di,160*4
		mov byte ptr es:[di],'2'
		jmp choose_option

isChooseThree:	mov di,160*4
		mov byte ptr es:[di],'3'
		call showtime
		jmp BOOT_START

isChooseFour:	mov di,160*4
		mov byte ptr es:[di],'4'
        call changetime
		jmp BOOT_START

;这里是展示界面
;=======================================================
showdashboard:
    push cx
    push ax
    push si
    push di
    mov ax,0b800h
    mov es,ax
    sub si,si
    mov di,8*160+30*2

    mov ax,dashboard
    mov ds,ax

    mov cx,8
loopdash:
    push cx

    mov cx,15
loopdash1:
    mov al,ds:[si]
    mov es:[di],al
    inc si
    add di,2
    loop loopdash1
    add di,130
    pop cx
    loop loopdash

    pop di
    pop si
    pop ax
    pop cx
    ret
;改变时间
;=======================================================
changetime:
        call clear_string_stack
        call clearscreen
        call show_string_stack
        CALL get_string
	CALL set_cmos_time

ret
;=======================================================
clear_string_stack:
        push bx
        push ds
        push si
        mov bx,0
		mov ds,bx
		mov si,OFFSET STRING_STACK - OFFSET Boot + 7E00H

		mov ds:[si],5959H
        add si,2
        mov ds:[si],4d4dH
        add si,2
        mov ds:[si],4444H
        add si,2
        mov ds:[si],6868H
        add si,2
        mov ds:[si],6d6dH
        add si,2
        mov ds:[si],7373H

        pop si
        pop ds
        pop bx
		ret


;=======================================================
show_string_stack:
		push si
		push di
        push bx
        push cx
        push ds
        push es

        mov bx,0
		mov ds,bx
        mov bx,timeshow
        mov es,bx
		mov si,OFFSET STRING_STACK - OFFSET Boot + 7E00H
		sub di,di

        mov cx,6
loopstack:
        mov bl,ds:[si]
        mov es:[di],bl
        mov bl,ds:[si+1]
        mov es:[di+1],bl
        add si,2
        add di,3
        loop loopstack
        MOV bx,0b800h
	    MOV ES,bx
		call print_time

        pop es
        pop ds
        pop cx
        pop bx
		pop di
		pop si
		ret

;=======================================================
set_cmos_time:
        push dx
        push DS
        PUSH SI
        PUSH bx
        PUSH CX
        PUSH ax
        mov bx,0
        mov ds,bx

        mov si,OFFSET STRING_STACK - OFFSET Boot + 7E00H		;STRING

		mov bx,OFFSET CMOS - OFFSET Boot + 7E00H		;CMOS

		mov cx,6


setCmosTime:	mov dx,ds:[si]							;'12' DX = '21'
		sub dh,30H							;dh = '2'	dl = '1'
		sub dl,30H
		shl dl,1
		shl dl,1
		shl dl,1
		shl dl,1
		and dh,00001111B

		or dl,dh

		mov al,ds:[bx]
		out 70H,al
		mov al,dl
		out 71H,al

		add si,2
		inc bx
		loop setCmosTime
	POP ax
	POP cx
	POP bx
	POP si
        pop ds
        pop dx
		ret
;=======================================================
get_string:
        push si
        push bx
        PUSH DS
        PUSH ax
        mov si,OFFSET STRING_STACK - OFFSET Boot + 7E00H
		mov bx,0
		MOV DS,bx
		call clear_buff

getString:	mov ah,0
		int 16H
		cmp al,'0'
		jb notNumber
		cmp al,'9'
		ja notNumber
		call char_push
		call show_string_stack
		jmp getString

isEnter:
	POP ax
	POP ds
        pop bx
        pop si
        ret

notNumber:	cmp ah,1CH
		je isEnter
		cmp ah,0EH
		je isBackSpace
		jmp getString

;=======================================================
isBackSpace:	call char_pop
		call show_string_stack
		jmp getString

;=======================================================
char_pop:
        cmp bx,0
		je charPopRet
		dec bx
		mov byte ptr ds:[si+bx],'?'

charPopRet:
            ret
;=======================================================
char_push:
        cmp bx,11
		ja charPushRet
		mov ds:[si+bx],al
		inc bx
charPushRet:
        ret

;=======================================================
showtime:
	call clearscreen
        mov ax,0b800h   ;显存空间首地址
        mov es,ax
        call print_time
        call set_new_int9
        MOV AX,0
        MOV DS,ax

readtime:
        mov cx,6
        mov si,OFFSET CMOS - OFFSET Boot + 7E00H
        mov di,12*160+26*2
SIXTIME:
        mov al,DS:[si]
        out 70h,al
        in al,71h

        mov ah,al
        shr ah,1
        shr ah,1
        shr ah,1
        shr ah,1
        and al,00001111b
        add ah,30h
        add al,30h

        mov es:[di],ah
        mov es:[DI+2],al

        inc si
        add di,6
        loop SIXTIME
        JMP readtime

        ret

print_time:
        push ax
        push bx
        push cx
        push si
        push DI
        PUSH ds
	    SUB DI,DI
        sub si,SI
        mov ax,timeshow
        mov ds,AX

        mov bx,12*160+26*2

change: mov cl,ds:[si]
        mov ch,0
        jcxz ok

        mov al,ds:[si]
        mov es:[bx+di],al
        inc SI
        ADD DI,2
        jmp short change

    ok: POP ds
    	pop di
        pop si
        pop cx
        pop bx
        pop ax
        RET

showDateOver:	call set_old_int9

		ret

;=======================================================
set_old_int9:
		push bx
		push es

		mov bx,0
		mov es,bx

		cli
		push es:[200H]
		pop es:[9*4]
		push es:[202H]
		pop es:[9*4+2]
		sti

		pop es
		pop bx
		ret
;=======================================================
set_new_int9:	push bx
		push es

		mov bx,0
		mov es,bx

		mov word ptr es:[9*4],OFFSET new_int9 - OFFSET Boot + 7E00H
		mov word ptr es:[9*4+2],0

		pop es
		pop bx
		ret
;=======================================================
new_int9:	push ax

		call clear_buff

		in al,60H
		pushf
		call dword ptr cs:[200H]

		cmp al,01H
		je isEsc
		cmp al,3BH
		jne int9Ret
		call changecolor


int9Ret:	pop ax
		iret


isEsc:		pop ax
		add sp,4
		popf
		jmp showDateOver

;=======================================================
changecolor:
    push ax
    push bx
    push cx
    push es
    mov ax,0b800h
    mov es,ax
    mov bx,1
    mov cx,2000
loopint9:
    inc byte ptr es:[bx]
    add bx,2
    loop loopint9

    pop es
    pop cx
    pop bx
    pop ax
    ret
;=======================================================
clear_buff:	mov ah,1
		int 16H
		jz clearBuffRet
		mov ah,0
		int 16H
		jmp clear_buff

clearBuffRet:	ret

;清屏，这里做了修改，为了不让F1的效果一直保留。
;=======================================================
clearscreen:
    push bx
    push cx
    push es
    mov bx,0b800h
    mov es,bx
    mov bx,0
    mov cx,2000
subclear:
    mov byte ptr es:[bx],' '
    add bx,2
    loop subclear

    pop es
    pop cx
    pop bx
    ret
;=======================================================
init_reg:
		mov bx,0B800H
		mov es,bx

		mov bx,0
		mov ds,bx
		ret

Boot_end:	nop

;========================================================
sav_old_int9:	mov bx,0
		mov es,bx

		push es:[9*4]
		pop es:[200H]
		push es:[9*4+2]
		pop es:[202H]

		ret
;========================================================
cpy_boot:
		mov bx,cs
		mov ds,bx
		mov si,OFFSET Boot

		mov bx,0
		mov es,bx
		mov di,7E00H

		mov cx,OFFSET Boot_end - OFFSET Boot
		cld
		rep movsb

		ret

code ends

end start
</code></pre>
<p>其实到这里也就可以停止了，磁盘读写有些无聊。</p>
<h3 id="效果"><a class="header" href="#效果">效果</a></h3>
<p><video src="./tmp-result.mp4" width="800px" height="600px" controls="controls"></video></p>
<h3 id="告一段落"><a class="header" href="#告一段落">告一段落</a></h3>
<p>磁盘读写没有搞，虚拟机做磁盘再那样调试我觉得很浪费时间。我上面的写法还有个问题就是dashboard没复制过去，因此如果真是复制到软盘大概率什么都没有。(但是会有功能，只是没显示)</p>
<h2 id="其他-3"><a class="header" href="#其他-3">其他</a></h2>
<p>一开始写了很久也无法解决问题功能切换和回到dashboard的问题，后来才发现需要用到16号中断的1号功能，这个王爽书里没讲，有些奇怪，基本上搜了搜都是用到了这个书里没有的东西。这是唯一的难点，磁盘读写什么的其实不值一提。</p>
<p>在写好了dashboard和展示时间之后，基本上本次实验的目的也就达到了，最终也没什么兴趣再写磁盘读写相关的东西了，参考了很多网上的答案 <del>最后攒了一个</del> ，网上看到的答案也都列举在后面了。别的就没什么了。</p>
<h1 id="总结"><a class="header" href="#总结">总结</a></h1>
<p>到了这里，基本上王爽这本书的使命也就到头了。可以说是一个很好的入门书，但是不足也有很多，涉及的内容有些少了，应该与其他讲汇编语言的书配套使用。</p>
<h1 id="一些参考"><a class="header" href="#一些参考">一些参考</a></h1>
<p>看见一个老哥做的不错，他的<a href="https://blog.csdn.net/qq_66550041/article/details/122606740">链接</a>。</p>
<p>一个使用<a href="https://blog.csdn.net/goodcrony/article/details/92153256">其他环境实现的老哥</a></p>
<p>一个<a href="https://blog.csdn.net/chengshawen7815/article/details/100991195">参考</a></p>
<p>不错的<a href="https://blog.csdn.net/hne71/article/details/104050556">讲解</a></p>
<p>一个<a href="https://blog.csdn.net/cccp15/article/details/117454392">实现</a></p>
<p><a href="https://www.bilibili.com/video/BV1At411m753?p=184&amp;vd_source=77d47fcb2bac41ab4ad02f265b3273cf">B站的一个课，讲了这个作业</a></p>
<p><a href="https://blog.csdn.net/weixin_41944412/article/details/80836632">好像有很多都出自上面的B站课程，这里这个也是</a></p>
<p><a href="https://blog.csdn.net/apollon_krj/article/details/72026944">也是个搭环境的</a></p>
<p><a href="https://blog.csdn.net/m0_48836226/article/details/120718381">参考</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
